<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tour of the cctbx &mdash; CCTBX None documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'None',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="CCTBX None documentation" href="index.html" />
    <link rel="next" title="SCons - the backbone of the cctbx build system" href="build_system.html" />
    <link rel="prev" title="Installation overview" href="installation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="build_system.html" title="SCons - the backbone of the cctbx build system"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation overview"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">CCTBX None documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tour-of-the-cctbx">
<span id="tour"></span><h1><a class="toc-backref" href="#id1">Tour of the cctbx</a><a class="headerlink" href="#tour-of-the-cctbx" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#tour-of-the-cctbx" id="id1">Tour of the cctbx</a><ul>
<li><a class="reference internal" href="#the-beach-in-the-box" id="id2">The beach in the box</a></li>
<li><a class="reference internal" href="#at-the-very-bottom" id="id3">At the very bottom</a></li>
<li><a class="reference internal" href="#scitbx-array-family-flex" id="id4"><tt class="docutils literal"><span class="pre">scitbx.array_family.flex</span></tt></a></li>
<li><a class="reference internal" href="#cctbx-array-family-flex" id="id5"><tt class="docutils literal"><span class="pre">cctbx.array_family.flex</span></tt></a></li>
<li><a class="reference internal" href="#a-balancing-act" id="id6">A balancing act</a></li>
<li><a class="reference internal" href="#hybrid-systems" id="id7">Hybrid systems</a></li>
<li><a class="reference internal" href="#building-bridges" id="id8">Building bridges</a></li>
<li><a class="reference internal" href="#thinking-hybrid" id="id9">Thinking hybrid</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="the-beach-in-the-box">
<h2><a class="toc-backref" href="#id2">The beach in the box</a><a class="headerlink" href="#the-beach-in-the-box" title="Permalink to this headline">¶</a></h2>
<p>If you go to the beach you will find massive amounts of a material known
to crystallographers as quartz, which in this case is just a fancy word
for sand. As an example here is the cctbx way of playing in the sandbox:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">xray</span>
<span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">crystal</span>
<span class="kn">from</span> <span class="nn">cctbx.array_family</span> <span class="kn">import</span> <span class="n">flex</span>

<span class="n">quartz_structure</span> <span class="o">=</span> <span class="n">xray</span><span class="o">.</span><span class="n">structure</span><span class="p">(</span>
  <span class="n">special_position_settings</span><span class="o">=</span><span class="n">crystal</span><span class="o">.</span><span class="n">special_position_settings</span><span class="p">(</span>
    <span class="n">crystal_symmetry</span><span class="o">=</span><span class="n">crystal</span><span class="o">.</span><span class="n">symmetry</span><span class="p">(</span>
      <span class="n">unit_cell</span><span class="o">=</span><span class="p">(</span><span class="mf">5.01</span><span class="p">,</span><span class="mf">5.01</span><span class="p">,</span><span class="mf">5.47</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">120</span><span class="p">),</span>
      <span class="n">space_group_symbol</span><span class="o">=</span><span class="s">&quot;P6222&quot;</span><span class="p">)),</span>
  <span class="n">scatterers</span><span class="o">=</span><span class="n">flex</span><span class="o">.</span><span class="n">xray_scatterer</span><span class="p">([</span>
    <span class="n">xray</span><span class="o">.</span><span class="n">scatterer</span><span class="p">(</span>
      <span class="n">label</span><span class="o">=</span><span class="s">&quot;Si&quot;</span><span class="p">,</span>
      <span class="n">site</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">),</span>
      <span class="n">u</span><span class="o">=</span><span class="mf">0.2</span><span class="p">),</span>
    <span class="n">xray</span><span class="o">.</span><span class="n">scatterer</span><span class="p">(</span>
      <span class="n">label</span><span class="o">=</span><span class="s">&quot;O&quot;</span><span class="p">,</span>
      <span class="n">site</span><span class="o">=</span><span class="p">(</span><span class="mf">0.197</span><span class="p">,</span><span class="o">-</span><span class="mf">0.197</span><span class="p">,</span><span class="mf">0.83333</span><span class="p">),</span>
      <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">)]))</span>

<span class="n">quartz_structure</span><span class="o">.</span><span class="n">show_summary</span><span class="p">()</span><span class="o">.</span><span class="n">show_scatterers</span><span class="p">()</span>
</pre></div>
</div>
<p>Running this script with <a class="reference external" href="http://www.python.org/">Python</a> produces the output:</p>
<div class="highlight-python"><div class="highlight"><pre>Number of scatterers: 2
It special positions: 2
Unit cell: (5.01, 5.01, 5.47, 90, 90, 120)
Space group: P 62 2 2 (No. 180)
Label  M  Coordinates            Occ  Uiso or Ustar
Si     3  0.5000  0.5000  0.3333 1.00 0.2000
O      6  0.1970 -0.1970  0.8333 1.00 0.0000
</pre></div>
</div>
<p>Note that the script is pure Python, even though at first sight the
format might appear to be specifically designed for crystallographic
data. Now let&#8217;s give the <tt class="docutils literal"><span class="pre">quartz_structure</span></tt> a rest break at the
beach:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">libtbx</span> <span class="kn">import</span> <span class="n">easy_pickle</span>
<span class="n">easy_pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s">&quot;beach&quot;</span><span class="p">,</span> <span class="n">quartz_structure</span><span class="p">)</span>
</pre></div>
</div>
<p>This creates a file with the name <tt class="docutils literal"><span class="pre">beach</span></tt> containing all the
information required for restoring the <tt class="docutils literal"><span class="pre">quartz_structure</span></tt> <strong>object</strong>,
which is the technical term for the entire hierarchy of data
referenced by the <tt class="docutils literal"><span class="pre">quartz_structure</span></tt> identifier in the Python
script. A very important point to notice is that the <tt class="docutils literal"><span class="pre">easy_pickle</span></tt>
module used for storing the <tt class="docutils literal"><span class="pre">quartz_structure</span></tt> is not specific to our
object. <tt class="docutils literal"><span class="pre">easy_pickle</span></tt> will store and restore (almost) any
user-defined Python object.</p>
<p>Being automatically generated, the <tt class="docutils literal"><span class="pre">beach</span></tt> file is not pretty to look
at, but this is not important because we can easily resurrect the
original object to extract any information that we might be interested
in. In a potentially <em>different script</em> on a potentially <em>different
computer</em> with a potentially <em>different operating system</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">libtbx</span> <span class="kn">import</span> <span class="n">easy_pickle</span>
<span class="n">quartz_structure</span> <span class="o">=</span> <span class="n">easy_pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&quot;beach&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that it is not necessary to explicitly import the relevant cctbx
modules in this script. Python&#8217;s <tt class="docutils literal"><span class="pre">pickle</span></tt> module does it for us
automatically after inspecting the <tt class="docutils literal"><span class="pre">beach</span></tt> file.</p>
<p>In practice a &#8220;live object&#8221; in memory is much more valuable than
information stored in a good-old file format because there are often
many different questions one can ask about particular real-world
objects. For example, we could ask: What are the site symmetries of the
atoms in the <tt class="docutils literal"><span class="pre">quartz_structure</span></tt>? Here is how we ask that question in
Python&#8217;s language:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">scatterer</span> <span class="ow">in</span> <span class="n">quartz_structure</span><span class="o">.</span><span class="n">scatterers</span><span class="p">():</span>
  <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="n">scatterer</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&quot;</span><span class="si">%8.4f</span><span class="s"> </span><span class="si">%8.4f</span><span class="s"> </span><span class="si">%8.4f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">scatterer</span><span class="o">.</span><span class="n">site</span>
  <span class="n">site_symmetry</span> <span class="o">=</span> <span class="n">quartz_structure</span><span class="o">.</span><span class="n">site_symmetry</span><span class="p">(</span><span class="n">scatterer</span><span class="o">.</span><span class="n">site</span><span class="p">)</span>
  <span class="k">print</span> <span class="s">&quot;  point group type:&quot;</span><span class="p">,</span> <span class="n">site_symmetry</span><span class="o">.</span><span class="n">point_group_type</span><span class="p">()</span>
  <span class="k">print</span> <span class="s">&quot;  special position operator:&quot;</span><span class="p">,</span>  <span class="n">site_symmetry</span><span class="o">.</span><span class="n">special_op</span><span class="p">()</span>
</pre></div>
</div>
<p>Answer:</p>
<div class="highlight-python"><div class="highlight"><pre>Si:   0.5000   0.5000   0.3333
  point group type: 222
  special position operator: 1/2,1/2,1/3
O:   0.1970  -0.1970   0.8333
  point group type: 2
  special position operator: 1/2*x-1/2*y,-1/2*x+1/2*y,5/6
</pre></div>
</div>
<p>Another question we could ask: What are the structure factors up to
a resolution of d_min=2 Angstrom?</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f_calc</span> <span class="o">=</span> <span class="n">quartz_structure</span><span class="o">.</span><span class="n">structure_factors</span><span class="p">(</span><span class="n">d_min</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">f_calc</span><span class="p">()</span>
<span class="n">f_calc</span><span class="o">.</span><span class="n">show_summary</span><span class="p">()</span><span class="o">.</span><span class="n">show_array</span><span class="p">()</span>
</pre></div>
</div>
<p>Answer:</p>
<div class="highlight-python"><div class="highlight"><pre>Miller array info: None
Type of data: complex_double, size=7
Type of sigmas: None
Number of Miller indices: 7
Anomalous flag: None
Unit cell: (5.01, 5.01, 5.47, 90, 90, 120)
Space group: P 62 2 2 (No. 180)
(1, 0, 0) (-11.3483432953-3.90019504038e-16j)
(1, 0, 1) (-14.9620947104-25.915108226j)
(1, 0, 2) (1.46915343413-2.54464839202j)
(1, 1, 0) (-12.8387095938+0j)
(1, 1, 1) (5.39203951708-9.3392864j)
(2, 0, 0) (-1.80942693741-2.84059649279e-16j)
(2, 0, 1) (4.95031293935+8.57419352432j)
</pre></div>
</div>
<p>Now we could turn our attention to the new <tt class="docutils literal"><span class="pre">f_calc</span></tt> object and start
asking different questions. For example: What are the d-spacings?</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f_calc</span><span class="o">.</span><span class="n">d_spacings</span><span class="p">()</span><span class="o">.</span><span class="n">show_array</span><span class="p">()</span>
</pre></div>
</div>
<p>Answer:</p>
<div class="highlight-python"><div class="highlight"><pre>(1, 0, 0) 4.33878727296
(1, 0, 1) 3.39927502294
(1, 0, 2) 2.31368408207
(1, 1, 0) 2.505
(1, 1, 1) 2.27753582331
(2, 0, 0) 2.16939363648
(2, 0, 1) 2.01658808355
</pre></div>
</div>
<p>Sometimes questions alone are not enough. We actually want to do
something.  For example select only low-resolution intensities:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">low_resolution_only</span> <span class="o">=</span> <span class="n">f_calc</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">f_calc</span><span class="o">.</span><span class="n">d_spacings</span><span class="p">()</span><span class="o">.</span><span class="n">data</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">low_resolution_only</span><span class="o">.</span><span class="n">show_array</span><span class="p">()</span>
</pre></div>
</div>
<p>Answer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="o">-</span><span class="mf">11.3483432953</span><span class="o">-</span><span class="mf">3.90019504038e-16j</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="o">-</span><span class="mf">14.9620947104</span><span class="o">-</span><span class="mf">25.915108226j</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="o">-</span><span class="mf">12.8387095938</span><span class="o">+</span><span class="mi">0j</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, the cctbx does not have a canned answer to every question,
even if it is a reasonable question. Fortunately, by virtue of being a
Python based system, the cctbx does lend itself to being extended and
embedded in order to form answers to questions that one might come
across. The cctbx has now reached a degree of completeness where this
can quite often be done without venturing into the deeper and darker
layers, the C++ core that we haven&#8217;t so far presented.</p>
</div>
<div class="section" id="at-the-very-bottom">
<h2><a class="toc-backref" href="#id3">At the very bottom</a><a class="headerlink" href="#at-the-very-bottom" title="Permalink to this headline">¶</a></h2>
<p>Python is a great language for just about everything. It is just
unfortunate that we do not currently have machines smart enough to turn
any Python script into efficient machine language (but visit the <a class="reference external" href="http://psyco.sourceforge.net/">PSYCO</a>
web site to witness mankind stretching out its feelers in that
direction). Certainly, future generations will pity us for having to
resort to counting bits and bytes in order to get our work done
(imagine yourself with a set of <a class="reference external" href="http://bca.cryst.bbk.ac.uk/bca/CNews/1998/Dec98/strips.html">Beevers-Lipson strips</a> getting ready
for a structure factor calculation).</p>
<p>Some core components of the cctbx started out as &#8216;C&#8217; libraries (SgInfo,
AtomInfo). Moving from &#8216;C&#8217; to C++ including the Standard Template
Library (STL) was a major step away from the bits-and-bytes counting
era. For example, switching to C++ exception handling for dealing with
errors reduced the source code size significantly and resulted in much
improved readability. Equally important, using <tt class="docutils literal"><span class="pre">std::vector</span></tt> for
managing dynamically allocated memory was a huge improvement over using
&#8216;C&#8217; style raw memory allocation functions (<tt class="docutils literal"><span class="pre">malloc()</span></tt> and <tt class="docutils literal"><span class="pre">free()</span></tt>).
However, the idea of using <tt class="docutils literal"><span class="pre">std::vector</span></tt> throughout the cctbx wasn&#8217;t
very satisfactory: for small arrays such as 3x3 rotation matrices the
dynamic memory allocation overhead can become a rate-limiting factor,
and for large arrays the copy-semantics enforce a coding style that
is difficult to follow. For example, consider a member function of a
space group class that computes an array of multiplicities given an
array of Miller indices. The scalar version of this function would
certainly look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>int multiplicity(miller::index&lt;&gt; const&amp; h);
</pre></div>
</div>
<p>Here is the direct translation to a vector version:</p>
<div class="highlight-python"><div class="highlight"><pre>std::vector&lt;int&gt; multiplicity(std::vector&lt;miller::index&lt;&gt; &gt; const&amp; h);
</pre></div>
</div>
<p>However, <tt class="docutils literal"><span class="pre">std::vector</span></tt> has deep-copy semantics (the same is true for
<tt class="docutils literal"><span class="pre">std::valarray</span></tt>). This results in the following:</p>
<div class="highlight-python"><div class="highlight"><pre>std::vector&lt;int&gt; multiplicity(std::vector&lt;miller::index&lt;&gt; &gt; const&amp; h)
{
  std::vector&lt;int&gt; result; // Constructs the array.
  result.reserve(h.size()); // Optional, but improves performance.
  for(std::size_t i=0; i&lt;h.size();i++) { // Loops over all Miller indices.
    result.push_back(multiplicity(h[i])); // Uses the scalar overload
  }                                       // to do the actual work.
  return result; // Ouch!
}
</pre></div>
</div>
<p>&#8220;Ouch&#8221; indicates that the <em>entire array</em> is copied when the function
returns!  While this might still be acceptable for arrays of Miller
indices which are mostly of moderate size, it becomes a real burden
when dealing with large maps. But returning to the example, in order to
avoid the copying overhead the function above could be coded as:</p>
<div class="highlight-python"><div class="highlight"><pre>void multiplicity(std::vector&lt;miller::index&lt;&gt; &gt; const&amp; h,
                  std::vector&lt;int&gt;&amp; result);
</pre></div>
</div>
<p>Unfortunately this is not only harder to read, but also more difficult
to use because the result has to be instantiated before the function
is called. This prevents convenient chaining of the type used in the
<tt class="docutils literal"><span class="pre">quartz_structure</span></tt> examples above.</p>
<p>Other major problems are the absence of a multi-dimensional array
type in the STL and limited support for algebraic array operations. We
considered using <a class="reference external" href="http://www.oonumerics.org/blitz/">Blitz++</a>, and <a class="reference external" href="http://www.boost.org/libs/multi_array/doc/">boost::multi_array</a>, but these do only
partially meet our specific requirements. For small arrays we actively
used <a class="reference external" href="http://www.boost.org/libs/array/">boost::array</a> for some time, but this was also not entirely
satisfactory due to the lack of convenient constructors which again
prevents chaining. So eventually we started the major effort of
implementing a family of small and large array types that address all
our requirements and are as uniform as possible: the scitbx array family.</p>
</div>
<div class="section" id="scitbx-array-family-flex">
<h2><a class="toc-backref" href="#id4"><tt class="docutils literal"><span class="pre">scitbx.array_family.flex</span></tt></a><a class="headerlink" href="#scitbx-array-family-flex" title="Permalink to this headline">¶</a></h2>
<p>The scitbx array family forms the backbone of the cctbx project. Viewed
from the C++ side the family is quite big and diverse, but viewed from
the Python side things are a lot simpler, as usual. All small C++ array
types are transparently mapped to standard Python tuples. This gives
immediate access to the rich and familiar set of standard tools for
manipulating tuples. All large array types are transparently and
uniformly mapped to a group of Python types in the
<tt class="docutils literal"><span class="pre">scitbx.array_family.flex</span></tt> module. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scitbx.array_family</span> <span class="kn">import</span> <span class="n">flex</span>
<span class="n">flex</span><span class="o">.</span><span class="n">double</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="c"># a 1-dimensional array of 30 double-precision values</span>
<span class="n">flex</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">flex</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="c"># a 2-dimensional array of 2x3 integer values</span>
</pre></div>
</div>
<p>For numeric element types the <tt class="docutils literal"><span class="pre">flex</span></tt> type supports algebraic operations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">flex</span><span class="o">.</span><span class="n">double</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">flex</span><span class="o">.</span><span class="n">double</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
<span class="go">(4.0, 4.0, 4.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">flex</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">))</span>
<span class="go">(2.0, 2.0, 2.0)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">flex</span></tt> type also supports a large number of other functions
(<tt class="docutils literal"><span class="pre">abs</span></tt>, <tt class="docutils literal"><span class="pre">sin</span></tt>, <tt class="docutils literal"><span class="pre">pow</span></tt>, etc.), slicing, and as seen in the
<tt class="docutils literal"><span class="pre">quartz_structure</span></tt> example above, pickling.</p>
<p>If all this looks similar to the popular <a class="reference external" href="http://numeric.scipy.org/">Numeric</a> module: it is at the
surface. However, there are two very important differences:</p>
<ul class="simple">
<li>Under the hood the <tt class="docutils literal"><span class="pre">flex</span></tt> types are instantiations of a C++ array type
that resembles familiar STL container types as much as possible.
In contrast Numeric presents itself with a raw &#8216;C&#8217; API.</li>
<li>It is straightforward to implement other <tt class="docutils literal"><span class="pre">flex</span></tt> types with custom
user-defined element types, even outside the scitbx module. This
would be extremely difficult to do with Numeric, and is virtually
impossible if the user-defined types are implemented in C++.</li>
</ul>
</div>
<div class="section" id="cctbx-array-family-flex">
<h2><a class="toc-backref" href="#id5"><tt class="docutils literal"><span class="pre">cctbx.array_family.flex</span></tt></a><a class="headerlink" href="#cctbx-array-family-flex" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">cctbx.array_family.flex</span></tt> inherits all <tt class="docutils literal"><span class="pre">flex</span></tt> types from the
<tt class="docutils literal"><span class="pre">scitbx.array_family.flex</span></tt> module and adds a few types specific to
the cctbx module, for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cctbx.array_family</span> <span class="kn">import</span> <span class="n">flex</span>
<span class="n">flex</span><span class="o">.</span><span class="n">miller_index</span><span class="p">(((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="n">flex</span><span class="o">.</span><span class="n">hendrickson_lattman</span><span class="p">(((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)))</span>
</pre></div>
</div>
<p>Another example is <tt class="docutils literal"><span class="pre">flex.xray_scatterer</span></tt> used in the
<tt class="docutils literal"><span class="pre">quartz_structure</span></tt> above.  The cctbx specific C++ code for
establishing these Python types is fairly minimal (about 470 lines for
exposing 6 types, including full pickle support and all copyright
statements). This approach can therefore be easily adopted for
user-defined types in other modules.</p>
</div>
<div class="section" id="a-balancing-act">
<h2><a class="toc-backref" href="#id6">A balancing act</a><a class="headerlink" href="#a-balancing-act" title="Permalink to this headline">¶</a></h2>
<p>Python&#8217;s <strong>convenience of use</strong> is directly related to the way the
Python type system works: all type information is evaluated at runtime.
For example consider this trivial function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>It works instantly for many different argument types:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plus</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c"># integer values</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plus</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2j</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">3j</span><span class="p">)</span> <span class="c"># complex values</span>
<span class="go">(3+5j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plus</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">])</span> <span class="c"># lists</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
</pre></div>
</div>
<p>It works because the meaning of <tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></tt> is determined at runtime
based on the actual types of <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>.</p>
<p>The <strong>runtime efficiency</strong> of C++ code is directly related to the way
the C++ type system works: type information is usually evaluated at
compile-time (virtual functions are an exception which we will not
consider here). Fortunately C++ has a very powerful mechanism that
helps us avoid explicitly coding polymorphic functions over and over
again:</p>
<div class="highlight-python"><div class="highlight"><pre>template &lt;typename T&gt;
T plus(T const&amp; a, T const&amp; b)
{
  return a + b;
}
</pre></div>
</div>
<p>This template function is automatically <em>instantiated</em> for a given type
<tt class="docutils literal"><span class="pre">T</span></tt> as used:</p>
<div class="highlight-python"><div class="highlight"><pre>int a = 1;
int b = 2;
int c = plus(a, b); // implicitly instantiates plus with T==int
</pre></div>
</div>
<p>Given a system that is based on both Python and C++ we have the freedom
of choosing the quick-and-easy runtime polymorphism offered by Python,
or the more efficient compile-time polymorphism offered by C++.</p>
<p>An important consideration in deciding which solution is the most
appropriate for a given problem is that a polymorphic Python function
requires very little memory at runtime. In contrast, each new
instantiation of a template function eventually results in a complete
copy of the corresponding machine language instructions tailored for
the specific types involved. This point may seem subtle at first, but
being overly generous with the use of C++ compile-time polymorphism can
lead to very large executable sizes and excessive compile times.</p>
<p>A comparison of the <tt class="docutils literal"><span class="pre">plus</span></tt> Python function and its C++ counterpart
shows that the notational overhead of the C++ syntax can easily double
the size of the source code. Therefore a programmer, given the choice,
will naturally lean towards the Python solution until the runtime
penalty due to the dynamic typing is prohibitive for a given
application. However, when putting a dynamically typed system and a
statically typed system together there are situations where it is
important to carefully consider the best balance.</p>
</div>
<div class="section" id="hybrid-systems">
<h2><a class="toc-backref" href="#id7">Hybrid systems</a><a class="headerlink" href="#hybrid-systems" title="Permalink to this headline">¶</a></h2>
<p>Considerations of the type discussed in the previous section directly
lead to the following situation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">flex</span><span class="o">.</span><span class="n">int</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">flex</span><span class="o">.</span><span class="n">double</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">TypeError: unsupported operand type(s) for *:</span>
<span class="go">&#39;scitbx_boost.array_family.flex_scitbx_ext.int&#39; and</span>
<span class="go">&#39;scitbx_boost.array_family.flex_scitbx_ext.double&#39;</span>
</pre></div>
</div>
<p>In passing we note that there is a simple solution which will produce
the desired result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span><span class="o">.</span><span class="n">as_double</span><span class="p">()</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<p>However, for the purpose of this discussion let&#8217;s pretend that this
solution does not exist. Of course the first question is: what is
the reason for the apparently stupid limitation?</p>
<p>As mentioned before, the Python <tt class="docutils literal"><span class="pre">flex</span></tt> types are implemented as
instantiations of C++ class templates. This ensures that all array
operations are very fast. However, from the discussion in the previous
section it follows that exposing the full class with its many member
functions to Python <strong>for each element type</strong> (<tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>,
<tt class="docutils literal"><span class="pre">miller::index&lt;&gt;</span></tt>, etc.) creates very sizable object files. If only
<em>homogeneous</em> operators (<tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">double</span> <span class="pre">*</span> <span class="pre">double</span></tt>, etc.) are
used the combined size of the object files scales linearly with the
number of element types involved. However, if the library is expanded
to support <em>heterogeneous</em> operators (<tt class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">double</span></tt>, <tt class="docutils literal"><span class="pre">double</span> <span class="pre">*</span>
<span class="pre">int</span></tt>, etc.) the combined object files grow proportional to the square
of the number of array element types involved! With current technology
this is simply prohibitive.</p>
<p>Limitations of the kind discussed here will apply to any hybrid
dynamically/statically typed system. In the broader picture the
limitation shown above is just one typical example. If we want to enjoy
the many benefits of using Python <em>and</em> have a system that produces
results with a reasonable runtime efficiency we have to adopt the
approach of sparsely sampling the space of possible C++ template
instantiations. For this idea to work in practice we need a powerful
and easy to use language-integration tool as discussed in the next
section.</p>
</div>
<div class="section" id="building-bridges">
<h2><a class="toc-backref" href="#id8">Building bridges</a><a class="headerlink" href="#building-bridges" title="Permalink to this headline">¶</a></h2>
<p>The cctbx project has evolved together with the <a class="reference external" href="http://www.boost.org/libs/python/doc/">Boost.Python</a> library.
All Python/C++ bindings in the cctbx project are implemented using this
library. Here is a simplified example of how it works in practice:</p>
<p>This is the C++ class that we want to use from Python:</p>
<div class="highlight-python"><div class="highlight"><pre>//! Parallelepiped that contains an asymmetric unit.
class brick
{
  public:
    //! Constructor.
    /*! Determines the parallelepiped given a space group type.
     */
    explicit
    brick(space_group_type const&amp; sg_type);

    //! Formats the information about the brick as a string.
    /*! Example: 0&lt;=x&lt;=1/8; -1/8&lt;=y&lt;=0; 1/8&lt;z&lt;7/8
     */
    std::string as_string() const;

    //! Tests if a given point is inside the brick.
    bool is_inside(tr_vec const&amp; p) const;
};
</pre></div>
</div>
<p>These are the corresponding Boost.Python bindings:</p>
<div class="highlight-python"><div class="highlight"><pre>class_&lt;brick&gt;(&quot;brick&quot;, no_init)
  .def(init&lt;space_group_type const&amp;&gt;())
  .def(&quot;__str__&quot;, &amp;brick::as_string)
  .def(&quot;is_inside&quot;, &amp;brick::is_inside)
;
</pre></div>
</div>
<p>And here is how the class is used in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">sgtbx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brick</span> <span class="o">=</span> <span class="n">sgtbx</span><span class="o">.</span><span class="n">brick</span><span class="p">(</span><span class="n">sgtbx</span><span class="o">.</span><span class="n">space_group_type</span><span class="p">(</span><span class="s">&quot;I a -3 d&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">brick</span>
<span class="go">0&lt;=x&lt;=1/8; -1/8&lt;=y&lt;=0; 1/8&lt;z&lt;7/8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brick</span><span class="o">.</span><span class="n">is_inside</span><span class="p">(</span><span class="n">sgtbx</span><span class="o">.</span><span class="n">tr_vec</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Typically it only takes a few minutes to implement the Python bindings
for a new class or function. Since it usually takes orders of
magnitudes longer to implement C++ classes and functions the extra time
spent on the Python bindings is in general negligible.</p>
</div>
<div class="section" id="thinking-hybrid">
<h2><a class="toc-backref" href="#id9">Thinking hybrid</a><a class="headerlink" href="#thinking-hybrid" title="Permalink to this headline">¶</a></h2>
<p>Boost.Python&#8217;s ease of use enables us to <em>think hybrid</em> when developing
new algorithms. We can conveniently start with a Python
implementation. The rich set of precompiled tools included in the
scitbx and the cctbx gives us a head start because many operations are
already carried out at C++ speed even though we are only using Python
to assemble the new functionality. If necessary, the working procedure
can be used to discover the rate-limiting sub-algorithms. To maximize
performance these can be reimplemented in C++, together with the Python
bindings needed to tie them back into the existing higher-level
procedure.</p>
<p>To give an example, this approach was used in the development of the
<em>Euclidean model matching algorithm</em> found in the cctbx
(<tt class="docutils literal"><span class="pre">cctbx/euclidean_model_matching.py</span></tt>). This algorithm is used to
compare heavy-atom substructures or anomalously scattering
substructures from isomorphous replacement or anomalous diffraction
experiments. The algorithm was first implemented in about 300 lines of
pure Python. We wrote another 200 lines of comprehensive regression
tests for thoroughly debugging the implementation. For a while the pure
Python code actually worked fast enough for us, until we started to
work with a very large substructure with 66 anomalous scatterers. Some
simple optimizations of the Python implementation resulted only in a
modest speedup, but after replacing about 30 lines of Python with a
C++ implementation the algorithm runs about 50 times faster.</p>
<p>Of course there is still more to gain by reimplementing the entire
algorithm in C++. However, one has to keep in mind that developing C++
code is typically much more time-consuming than developing in Python.
For example, the 30 lines of Python mentioned in the previous paragraph
turned into more then 100 lines of C++, not counting the additional 13
lines for the Boost.Python bindings. It is also important to keep in
mind that developing maintainable C++ code requires much more
hard-earned working experience than developing useful Python code.  C++
has many pitfalls that one must learn to avoid. In contrast the Python
language is structured in a way that steers even the novice programmer
onto safe routes. In fact, Python was originally conceived as a
language for teaching programming. Amazingly this heritage is still
preserved even though Python has grown to be a very richly featured
language.</p>
<p>Looking back, the cctbx started out mainly as a library of C++ classes
with &#8216;C&#8217; heritage, and for a while the growth was mainly concentrated
on the C++ parts. However, a very important difference between the 1.0
release and the upcoming 2.0 release is that the Python parts now
constitute a much more significant fraction of the total sources. We
expect this trend to continue, as illustrated qualitatively in this
figure:</p>
<img alt="_images/python_cpp_mix.png" src="_images/python_cpp_mix.png" />
<p>This figure shows the ratio of newly added C++ and Python code over
time as new applications are implemented. We expect this ratio to level
out near 70% Python. From an inside viewpoint the increasing ability to
solve new problems mostly with the easy-to-use Python language rather
than a necessarily more arcane statically typed language is the return
on a major investment, namely our involvement in the development of
Boost.Python. From an outside viewpoint we hope that the ability to
solve some problems entirely using only Python will enable a larger
group of scientist to participate in the rapid development of new
algorithms. It is also important to notice that Python is an ideal
language for integrating diverse existing tools, no matter which
language they are written in. If portability is not an issue this can
be a great solution to some problems. We are convinced that the cctbx
can be very useful as an intelligent mediator between otherwise
incompatible crystallographic applications.</p>
<p><a class="reference internal" href="index.html#introduction"><em>Back</em></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Tour of the cctbx</a><ul>
<li><a class="reference internal" href="#the-beach-in-the-box">The beach in the box</a></li>
<li><a class="reference internal" href="#at-the-very-bottom">At the very bottom</a></li>
<li><a class="reference internal" href="#scitbx-array-family-flex"><tt class="docutils literal"><span class="pre">scitbx.array_family.flex</span></tt></a></li>
<li><a class="reference internal" href="#cctbx-array-family-flex"><tt class="docutils literal"><span class="pre">cctbx.array_family.flex</span></tt></a></li>
<li><a class="reference internal" href="#a-balancing-act">A balancing act</a></li>
<li><a class="reference internal" href="#hybrid-systems">Hybrid systems</a></li>
<li><a class="reference internal" href="#building-bridges">Building bridges</a></li>
<li><a class="reference internal" href="#thinking-hybrid">Thinking hybrid</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installation overview</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="build_system.html"
                        title="next chapter">SCons - the backbone of the cctbx build system</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tour.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="build_system.html" title="SCons - the backbone of the cctbx build system"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation overview"
             >previous</a> |</li>
        <li><a href="index.html">CCTBX None documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, University of California.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>