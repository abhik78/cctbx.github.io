<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cctbx.miller package &mdash; CCTBX None documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'None',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="CCTBX None documentation" href="../index.html" />
    <link rel="up" title="cctbx - core crystallographic objects and functions" href="cctbx.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">CCTBX None documentation</a> &raquo;</li>
          <li><a href="cctbx.html" accesskey="U">cctbx - core crystallographic objects and functions</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-cctbx.miller"></span><div class="section" id="cctbx-miller-package">
<h1>cctbx.miller package<a class="headerlink" href="#cctbx-miller-package" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="#module-cctbx.miller" title="cctbx.miller"><tt class="xref py py-mod docutils literal"><span class="pre">cctbx.miller</span></tt></a> is one of the most important modules in CCTBX; it
encompasses nearly every operation performed directly on experimental data.
The core classes in cctbx.miller are the <em class="xref std std-ref">set</em> and the
<em class="xref std std-ref">array</em>.  The set (not to be confused with the built-in
Python type) contains the crystal symmetry, an array (type
<tt class="xref py py-class docutils literal"><span class="pre">cctbx.array_family.flex.miller_index</span></tt>) of Miller indices (h,k,l),
and a boolean flag indicating anomalous pairs.  It does not contain actual
data, although many of its methods will return an array.  The array subclasses
the Miller set and adds a flex array containing data (and, optionally, a
flex array of experimental sigmas) and many extensions for supporting a variety
of data types.  The underlying &#8220;data&#8221; is often X-ray amplitudes or intensities,
but many other array types are also supported.</p>
<p>One important distinction needs to be made for developers used to working with
specific file formats or more archaic programming languages: <strong>the Miller
arrays that you will work with do not necessarily correspond to a single
column of data in a reflection file</strong>.  There are several major differences:</p>
<ul class="simple">
<li><strong>Friedel mates</strong> will be stored separate if present.  This means that a
pair of columns <tt class="docutils literal"><span class="pre">F(+)</span></tt> and <tt class="docutils literal"><span class="pre">F(-)</span></tt> from an MTZ file will become a single
array with both <tt class="docutils literal"><span class="pre">(h,k,l)</span></tt> and <tt class="docutils literal"><span class="pre">(-h,-k,-l)</span></tt> present as distinct items.
The same also applies to any other data type.  (Note that one consequence
of this behavior is that the number of reflections will appear to
double-count acentric reflections for which both Friedel mates are present.)</li>
<li>For <strong>experimental data</strong> (amplitudes or intensities), the array will also
store the corresponding experimental sigmas; <tt class="docutils literal"><span class="pre">array.data()</span></tt> returns the
experimental data, while <tt class="docutils literal"><span class="pre">array.sigmas()</span></tt> returns sigmas.  In combination
with the treatment of anomalous data, this means that a single Miller array
can represent the combination of columns <tt class="docutils literal"><span class="pre">I(+),SIGI(+),I(-),SIGI(-)</span></tt> from
a file.</li>
<li><strong>Weighted map coefficients</strong> such as <tt class="docutils literal"><span class="pre">FWT,DELFWT</span></tt> or <tt class="docutils literal"><span class="pre">2FOFCWT,PH2FOFCWT</span></tt>
will be treated as a single array with data type
<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.complex_double" title="scitbx.array_family.flex.complex_double"><tt class="xref py py-class docutils literal"><span class="pre">scitbx.array_family.flex.complex_double</span></tt></a>.</li>
<li><strong>Hendrickson-Lattman</strong> phase probability coefficients are also grouped
together, and have their own data type
<tt class="xref py py-class docutils literal"><span class="pre">cctbx.array_family.flex.hendrickson_lattman</span></tt>.</li>
</ul>
<p>These conventions greatly simplify keeping track of and manipulating related
data items.
Output to various file formats will still follow the appropriate conventions.</p>
<div class="section" id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>Miller sets (and arrays) can be created in three ways: programatically, by
reading from a file, or from a <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><tt class="xref py py-class docutils literal"><span class="pre">cctbx.xray.structure</span></tt></a> object.  (In
practice, the latter two options almost always return an array object rather
than a set.)  Programmatic creation can be done directly, or through the
convenience method <a class="reference internal" href="#cctbx.miller.build_set" title="cctbx.miller.build_set"><tt class="xref py py-func docutils literal"><span class="pre">cctbx.miller.build_set()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">miller</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">crystal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">build_set</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">crystal_symmetry</span><span class="o">=</span><span class="n">crystal</span><span class="o">.</span><span class="n">symmetry</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">space_group_symbol</span><span class="o">=</span><span class="s">&quot;P212121&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">unit_cell</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="n">anomalous_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">d_min</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ms</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">ms</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 2), (0, 1, 1), (0, 2, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (2, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ms</span><span class="o">.</span><span class="n">d_max_min</span><span class="p">()</span>
<span class="go">(4.242640687119285, 3.0)</span>
</pre></div>
</div>
<p>The same set, instantiated directly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">miller</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">crystal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx.array_family</span> <span class="kn">import</span> <span class="n">flex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms</span> <span class="o">=</span> <span class="n">miller</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">crystal_symmetry</span><span class="o">=</span><span class="n">crystal</span><span class="o">.</span><span class="n">symmetry</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">space_group_symbol</span><span class="o">=</span><span class="s">&quot;P212121&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">unit_cell</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="n">anomalous_flag</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">indices</span><span class="o">=</span><span class="n">flex</span><span class="o">.</span><span class="n">miller_index</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]))</span>
</pre></div>
</div>
<p>From here we can retrieve a variety of information, even before we have
experimental data.  For instance, exploring systematic absences (starting
from the above example):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cctbx</span> <span class="kn">import</span> <span class="n">sgtbx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point_group</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">space_group</span><span class="p">()</span><span class="o">.</span><span class="n">build_derived_point_group</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms_base</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span><span class="n">space_group</span><span class="o">=</span><span class="n">point_group</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms_all</span> <span class="o">=</span> <span class="n">ms_base</span><span class="o">.</span><span class="n">complete_set</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">lone_set</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">ms_base</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">sys_abs</span><span class="p">)</span>
<span class="go">&lt;class &#39;cctbx.miller.set&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 1), (0, 1, 0), (1, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ms_all_p212121</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span>
<span class="gp">... </span>  <span class="n">space_group_info</span><span class="o">=</span><span class="n">ms</span><span class="o">.</span><span class="n">space_group_info</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs_flags</span> <span class="o">=</span> <span class="n">ms_all_p212121</span><span class="o">.</span><span class="n">sys_absent_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="p">)</span>
<span class="go">&lt;class &#39;cctbx.miller.array&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 1), (0, 0, 2), (0, 1, 0), (0, 1, 1), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (2, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="go">[True, False, True, False, False, True, False, False, False, False]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all_p212121</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">sys_abs</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 1), (0, 1, 0), (1, 0, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_sys_abs</span> <span class="o">=</span> <span class="n">ms_all_p212121</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="n">sys_abs_flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">not_sys_abs</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>
<span class="go">[(0, 0, 2), (0, 1, 1), (0, 2, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (2, 0, 0)]</span>
</pre></div>
</div>
<p>This block of code performed the following actions:</p>
<ul class="simple">
<li>change the symmetry to the point group (<tt class="docutils literal"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></tt>) corresponding to the
original space group (<tt class="docutils literal"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></tt>)</li>
<li>generate the complete list of reflections for the new set in <tt class="docutils literal"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></tt></li>
<li>obtain the &#8220;lone set&#8221; of reflections missing from the original set relative
to the new complete set; these correspond to reflections that are
systematically absent in <tt class="docutils literal"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></tt> (but not <tt class="docutils literal"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></tt>)</li>
<li>change the symmetry for the complete set in <tt class="docutils literal"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">2</span> <span class="pre">2</span></tt> back to the original
space group <tt class="docutils literal"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></tt></li>
<li>call the method <tt class="docutils literal"><span class="pre">sys_absent_flags()</span></tt> to obtain a Miller array whose data
are a <tt class="docutils literal"><span class="pre">flex.bool</span></tt> array indicating those reflections that are
systematically absent</li>
<li>call the method <tt class="docutils literal"><span class="pre">select()</span></tt> using the resulting boolean array and its
inverse, first to extract the set of systematic absences for
<tt class="docutils literal"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></tt>, and then extract the non-absent set we started with</li>
</ul>
<p>There are two more important details that are not immediately obvious from
the code example:</p>
<p>1) <tt class="docutils literal"><span class="pre">customized_copy()</span></tt> will create a new <tt class="docutils literal"><span class="pre">set</span></tt> object, but it will not
copy any underlying <tt class="docutils literal"><span class="pre">flex</span></tt> arrays (the same applies to the <tt class="docutils literal"><span class="pre">array</span></tt>
class).  This means that modifications to these arrays via the new copy will
be propagated back to the original object.  If you want to avoid this
behavior, use the <tt class="docutils literal"><span class="pre">deep_copy()</span></tt> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ms_base</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span><span class="n">space_group</span><span class="o">=</span><span class="n">point_group</span><span class="p">)</span><span class="o">.</span><span class="n">deep_copy</span><span class="p">()</span>
</pre></div>
</div>
<p>2) The comparison of sets in <tt class="docutils literal"><span class="pre">lone_set()</span></tt>, and in general most other methods
that involve an <tt class="docutils literal"><span class="pre">other</span></tt> argument, will fail if the crystal symmetry is
not identical.  For instance, in the above example, if we instead tried to
call <tt class="docutils literal"><span class="pre">lone_set()</span></tt> using the original <tt class="docutils literal"><span class="pre">P</span> <span class="pre">21</span> <span class="pre">21</span> <span class="pre">21</span></tt> set as <tt class="docutils literal"><span class="pre">other</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">lone_set</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">ms</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1047</span>, in <span class="n">lone_set</span>
    <span class="n">assert_is_similar_symmetry</span><span class="o">=</span><span class="n">assert_is_similar_symmetry</span><span class="p">)</span><span class="o">.</span><span class="n">singles</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  File <span class="nb">&quot;/Users/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1007</span>, in <span class="n">match_indices</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_similar_symmetry</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="gr">AssertionError</span>
</pre></div>
</div>
<p>We can prevent this if we want:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sys_abs</span> <span class="o">=</span> <span class="n">ms_all</span><span class="o">.</span><span class="n">lone_set</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">ms</span><span class="p">,</span> <span class="n">assert_is_similar_symmetry</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>However, you should use caution when disabling the symmetry check, as this
will also mean that comparisons between radically different crystal symmetries
(e.g. <tt class="docutils literal"><span class="pre">P</span> <span class="pre">63</span> <span class="pre">2</span> <span class="pre">2</span></tt> versus <tt class="docutils literal"><span class="pre">I</span> <span class="pre">41</span></tt>) will be performed silently.</p>
</div>
<div class="section" id="file-i-o">
<h2>File I/O<a class="headerlink" href="#file-i-o" title="Permalink to this headline">¶</a></h2>
<p>Of course, if you are interested in working with actual experimental data,
additional APIs are required.  Methods for reading input files are covered in
more detail in the documentation for <a class="reference internal" href="../iotbx/iotbx.reflection_file_reader.html#module-iotbx.reflection_file_reader" title="iotbx.reflection_file_reader"><tt class="xref py py-mod docutils literal"><span class="pre">iotbx.reflection_file_reader</span></tt></a>
and <a class="reference internal" href="../iotbx/iotbx.file_reader.html#module-iotbx.file_reader" title="iotbx.file_reader"><tt class="xref py py-mod docutils literal"><span class="pre">iotbx.file_reader</span></tt></a>, but in the simplest case we can obtain
experimental data in just a couple of lines of code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">iotbx.reflection_file_reader</span> <span class="kn">import</span> <span class="n">any_reflection_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hkl_in</span> <span class="o">=</span> <span class="n">any_reflection_file</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s">&quot;data.sca&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">miller_arrays</span> <span class="o">=</span> <span class="n">hkl_in</span><span class="o">.</span><span class="n">as_miller_arrays</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span> <span class="o">=</span> <span class="n">miller_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>This of course assumes that the file format includes crystal symmetry, which
is not the case for some popular formats; in these cases you will need to
obtain the symmetry information separately and pass it to
<tt class="docutils literal"><span class="pre">as_miller_arrays()</span></tt>.</p>
<p>Some of the file metadata will be preserved in the embedded <tt class="docutils literal"><span class="pre">array_info</span></tt>
object; other attributes are properties of the array itself:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>
<span class="go">data.sca:I(+),SIGI(+),I(-),SIGI(-)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">observation_type</span><span class="p">()</span>
<span class="go">xray.intensity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span><span class="o">.</span><span class="n">show_summary</span><span class="p">()</span>
<span class="go">Miller array info: data.sca:I(+),SIGI(+),I(-),SIGI(-)</span>
<span class="go">Observation type: xray.intensity</span>
<span class="go">Type of data: double, size=7</span>
<span class="go">Type of sigmas: double, size=7</span>
<span class="go">Number of Miller indices: 7</span>
<span class="go">Anomalous flag: False</span>
<span class="go">Unit cell: (6.000, 6.000, 6.000, 90, 90, 90)</span>
<span class="go">Space group: P 21 21 21 (No. 19)</span>
<span class="go">&lt;cctbx.miller.array object at 0x1071a6690&gt;</span>
</pre></div>
</div>
<p>(The final line is simply printing the Python representation of the array
itself - this is because the <tt class="docutils literal"><span class="pre">show_summary()</span></tt> method returns a reference to
<tt class="docutils literal"><span class="pre">self</span></tt>, which allows <strong>chaining</strong> of successive methods.)  Note that the
<tt class="docutils literal"><span class="pre">array_info</span></tt> object returned by <tt class="docutils literal"><span class="pre">array.info()</span></tt> contains the file name
and original column labels; elsewhere, these attributes are used to select
specific arrays from multi-purpose formats such as MTZ.</p>
<p>From here we can quickly convert to amplitudes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span> <span class="o">=</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">f_sq_as_f</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">observation_type</span><span class="p">()</span>
<span class="go">xray.amplitude</span>
</pre></div>
</div>
<p>(Note that for macromolecular data, the more sophisticated French-Wilson
treatment is recommended for dealing sensibly with weak or negative
intensities; this can be performed by calling <tt class="docutils literal"><span class="pre">array.french_wilson()</span></tt>.  For
many purposes, however, the simpler and faster <tt class="docutils literal"><span class="pre">f_sq_as_f()</span></tt> will be
sufficient.)</p>
<p>The Miller array can also be easily output to CIF, MTZ, Scalepack (unmerged
format only), SHELX, or CNS formats, although some restrictions apply.  Some
of these methods (where the format is limited to certain data types) can
directly write to a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span><span class="o">.</span><span class="n">export_as_scalepack_unmerged</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s">&quot;data2.sca&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;data.hkl&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span><span class="o">.</span><span class="n">export_as_shelx_hklf</span><span class="p">(</span><span class="n">file_object</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Others require multiple steps, but this has the advantage of allowing multiple
arrays to be combined (provided that they have identical crystal symmetry):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span> <span class="o">=</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">as_mtz_dataset</span><span class="p">(</span><span class="n">column_root_label</span><span class="o">=</span><span class="s">&quot;I&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span><span class="o">.</span><span class="n">add_miller_array</span><span class="p">(</span><span class="n">f_obs</span><span class="p">,</span> <span class="n">column_root_label</span><span class="o">=</span><span class="s">&quot;F&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span><span class="o">.</span><span class="n">add_miller_array</span><span class="p">(</span><span class="n">r_free_flags</span><span class="p">,</span>
<span class="gp">... </span>  <span class="n">column_root_label</span><span class="o">=</span><span class="s">&quot;FreeR_flag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtz_dataset</span><span class="o">.</span><span class="n">mtz_object</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;data.mtz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to conventional formats, since all of the internal types can be
serialized as Python pickles, the same applies to set and array objects.</p>
<div class="section" id="processing-input-data-practical-aspects">
<h3>Processing input data - practical aspects<a class="headerlink" href="#processing-input-data-practical-aspects" title="Permalink to this headline">¶</a></h3>
<p>In practice, preparing input arrays for the various other algorithms in CCTBX
is often significantly more complicated than implied in the previous section.
Suppose for example we have an MTZ
file with these columns (output excerpted from <tt class="docutils literal"><span class="pre">phenix.mtz.dump</span> <span class="pre">data.mtz</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre>label      #valid  %valid    min     max type
H           75612 100.00% -40.00   38.00 H: index h,k,l
K           75612 100.00%   0.00   25.00 H: index h,k,l
L           75612 100.00%   0.00   70.00 H: index h,k,l
I(+)        74981  99.17% -11.10 2777.70 K: I(+) or I(-)
SIGI(+)     74981  99.17%   0.10   89.50 M: standard deviation
I(-)        69529  91.95% -14.00 2808.50 K: I(+) or I(-)
SIGI(-)     69529  91.95%   0.10   64.90 M: standard deviation
FreeR_flag  75773 100.00%   0.00    1.00 I: integer
</pre></div>
</div>
<p>We would eventually like to be able to use these data for calculation of
R-factors (versus some hypothetical set of structure factors derived from a
model or map).  This requires several steps to ensure that any subsequent
actions will behave sensibly: we must make sure that the input data are of
the correct type, symmetry-unique, using conventional indices, and consistent
with the R-free flags; we also want to use the R-free flags to separate out
&#8220;working&#8221; and &#8220;test&#8221; arrays.  To begin with, we read in the data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">iotbx.reflection_file_reader</span> <span class="kn">import</span> <span class="n">any_reflection_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hkl_in</span> <span class="o">=</span> <span class="n">any_reflection_file</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s">&quot;data.mtz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">miller_arrays</span> <span class="o">=</span> <span class="n">hkl_in</span><span class="o">.</span><span class="n">as_miller_arrays</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_obs</span> <span class="o">=</span> <span class="n">miller_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags</span> <span class="o">=</span> <span class="n">miller_arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span> <span class="o">=</span> <span class="n">i_obs</span><span class="o">.</span><span class="n">f_sq_as_f</span><span class="p">()</span><span class="o">.</span><span class="n">map_to_asu</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">customized_copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">map_to_asu</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">merge_equivalents</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">merge_equivalents</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flags_plus_minus</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">generate_bijvoet_mates</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span><span class="p">,</span> <span class="n">flags_plus_minus</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">flags_plus_minus</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs_work</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="n">flags_plus_minus</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs_free</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flags_plus_minus</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
</pre></div>
</div>
<p>By the end of this block of code, we have ensured that the experimental
amplitudes and R-free flags have identically sized and ordered arrays, and
are suitable for comparison with any other (similarly prepared) set of data.
A number of consistency checks built in to the various set and array methods
may raise exceptions if these steps are skipped - for instance, the separate
storage of <tt class="docutils literal"><span class="pre">(h,k,l)</span></tt> and <tt class="docutils literal"><span class="pre">(-h,-k,-l)</span></tt> requires us to expand the R-free
flags to be &#8220;anomalous&#8221;, and if we skip that step:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1032</span>, in <span class="n">common_sets</span>
    <span class="n">assert_is_similar_symmetry</span><span class="o">=</span><span class="n">assert_is_similar_symmetry</span><span class="p">)</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">1008</span>, in <span class="n">match_indices</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">anomalous_flag</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">anomalous_flag</span><span class="p">()</span>
<span class="gr">AssertionError</span>
</pre></div>
</div>
<p>Or if we omit the call to <tt class="docutils literal"><span class="pre">common_sets()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f_obs_work</span> <span class="o">=</span> <span class="n">f_obs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="n">flags_plus_minus</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/nat/src/cctbx_project/cctbx/miller/__init__.py&quot;</span>, line <span class="m">3232</span>, in <span class="n">select</span>
    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
<span class="gr">RuntimeError</span>: <span class="n">scitbx Internal Error: /home/nat/src/cctbx_project/scitbx/array_family/selections.h(44): SCITBX_ASSERT(flags.size() == self.size()) failure.</span>
</pre></div>
</div>
<p>(In practice, our use of <tt class="docutils literal"><span class="pre">common_sets()</span></tt> here is less than ideal; programs
in Phenix instead check that every reflection for which we have data also has
a corresponding R-free flag - after expansion to anomalous if necessary - and
exit with an error if this is not the case.)</p>
<p>Note that in the above example we are making many assumptions about the
contents and order of the input file, whereas in practice MTZ and CIF formats
may be arbitrarily complex and contain multiple arrays of each type.
(Additionally, the conventions for specifying R-free flags differ between
various software suites, and <tt class="docutils literal"><span class="pre">1</span></tt> will not necessarily be the appropriate
test flag value; fortunately, it is usually possible to guess the convention
being used.)   For
actual applications (as opposed to quick scripts and development code),
the utilities available in <tt class="xref py py-mod docutils literal"><span class="pre">iotbx.reflection_file_utils</span></tt> enable
standardized retrieval of different array types based on a combination of
automatic behavior and user input (i.e. label strings), and the general-purpose
input wrapper in <a class="reference internal" href="../mmtbx/mmtbx.command_line.html#module-mmtbx.command_line" title="mmtbx.command_line"><tt class="xref py py-mod docutils literal"><span class="pre">mmtbx.command_line</span></tt></a> encapsulates nearly all of these
steps.</p>
</div>
</div>
<div class="section" id="comparing-arrays">
<h2>Comparing arrays<a class="headerlink" href="#comparing-arrays" title="Permalink to this headline">¶</a></h2>
<p>Here is a slightly more complex example of comparing data output by a
refinement program.  The input arrays are assumed to already be merged and
in the same ASU, but normally this would be taken care of by previous routines.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compute_r_factors</span> <span class="p">(</span><span class="n">fobs</span><span class="p">,</span> <span class="n">fmodel</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="p">:</span>
  <span class="n">fmodel</span><span class="p">,</span> <span class="n">fobs</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">fobs</span><span class="p">)</span>
  <span class="n">fmodel</span><span class="p">,</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">common_sets</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
  <span class="n">fc_work</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">()))</span>
  <span class="n">fo_work</span> <span class="o">=</span> <span class="n">fobs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">()))</span>
  <span class="n">fc_test</span> <span class="o">=</span> <span class="n">fmodel</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
  <span class="n">fo_test</span> <span class="o">=</span> <span class="n">fobs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
  <span class="n">r_work</span> <span class="o">=</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">fc_work</span><span class="p">)</span>
  <span class="n">r_free</span> <span class="o">=</span> <span class="n">fo_test</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">fc_test</span><span class="p">)</span>
  <span class="k">print</span> <span class="s">&quot;r_work = </span><span class="si">%.4f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">r_work</span>
  <span class="k">print</span> <span class="s">&quot;r_free = </span><span class="si">%.4f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">r_free</span>
  <span class="k">print</span> <span class="s">&quot;&quot;</span>
  <span class="n">flags</span><span class="o">.</span><span class="n">setup_binner</span><span class="p">(</span><span class="n">n_bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
  <span class="n">fo_work</span><span class="o">.</span><span class="n">use_binning_of</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
  <span class="n">fc_work</span><span class="o">.</span><span class="n">use_binner_of</span><span class="p">(</span><span class="n">fo_work</span><span class="p">)</span>
  <span class="n">fo_test</span><span class="o">.</span><span class="n">use_binning_of</span><span class="p">(</span><span class="n">fo_work</span><span class="p">)</span>
  <span class="n">fc_test</span><span class="o">.</span><span class="n">use_binning_of</span><span class="p">(</span><span class="n">fo_work</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i_bin</span> <span class="ow">in</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">range_all</span><span class="p">()</span> <span class="p">:</span>
    <span class="n">sel_work</span> <span class="o">=</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">selection</span><span class="p">(</span><span class="n">i_bin</span><span class="p">)</span>
    <span class="n">sel_test</span> <span class="o">=</span> <span class="n">fo_test</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">selection</span><span class="p">(</span><span class="n">i_bin</span><span class="p">)</span>
    <span class="n">fo_work_bin</span> <span class="o">=</span> <span class="n">fo_work</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_work</span><span class="p">)</span>
    <span class="n">fc_work_bin</span> <span class="o">=</span> <span class="n">fc_work</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_work</span><span class="p">)</span>
    <span class="n">fo_test_bin</span> <span class="o">=</span> <span class="n">fo_test</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_test</span><span class="p">)</span>
    <span class="n">fc_test_bin</span> <span class="o">=</span> <span class="n">fc_test</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sel_test</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fc_test_bin</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span> <span class="k">continue</span>
    <span class="n">r_work_bin</span> <span class="o">=</span> <span class="n">fo_work_bin</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">fc_work_bin</span><span class="p">,</span>
      <span class="n">assume_index_matching</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">r_free_bin</span> <span class="o">=</span> <span class="n">fo_test_bin</span><span class="o">.</span><span class="n">r1_factor</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">fc_test_bin</span><span class="p">,</span>
      <span class="n">assume_index_matching</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">cc_work_bin</span> <span class="o">=</span> <span class="n">fo_work_bin</span><span class="o">.</span><span class="n">correlation</span><span class="p">(</span><span class="n">fc_work_bin</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient</span><span class="p">()</span>
    <span class="n">cc_free_bin</span> <span class="o">=</span> <span class="n">fo_test_bin</span><span class="o">.</span><span class="n">correlation</span><span class="p">(</span><span class="n">fc_test_bin</span><span class="p">)</span><span class="o">.</span><span class="n">coefficient</span><span class="p">()</span>
    <span class="n">legend</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">binner</span><span class="p">()</span><span class="o">.</span><span class="n">bin_legend</span><span class="p">(</span><span class="n">i_bin</span><span class="p">,</span> <span class="n">show_counts</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">  </span><span class="si">%8d</span><span class="s"> </span><span class="si">%8d</span><span class="s">  </span><span class="si">%.4f</span><span class="s"> </span><span class="si">%.4f</span><span class="s">  </span><span class="si">%.3f</span><span class="s"> </span><span class="si">%.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="n">fo_work_bin</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span>
      <span class="n">fo_test_bin</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">r_work_bin</span><span class="p">,</span> <span class="n">r_free_bin</span><span class="p">,</span> <span class="n">cc_work_bin</span><span class="p">,</span> <span class="n">cc_free_bin</span><span class="p">)</span>
</pre></div>
</div>
<p>(The full source code is available in
<tt class="docutils literal"><span class="pre">iotbx/examples/recalculate_phenix_refine_r_factors.py</span></tt>.)</p>
</div>
<div class="section" id="working-with-experimental-data">
<h2>Working with experimental data<a class="headerlink" href="#working-with-experimental-data" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
<div class="section" id="from-arrays-to-maps">
<h2>From arrays to maps<a class="headerlink" href="#from-arrays-to-maps" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fft_map</span> <span class="o">=</span> <span class="n">map_coeffs</span><span class="o">.</span><span class="n">fft_map</span><span class="p">(</span><span class="n">resolution_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
<span class="n">fft_map</span><span class="o">.</span><span class="n">apply_sigma_scaling</span><span class="p">()</span>
<span class="n">real_map</span> <span class="o">=</span> <span class="n">fft_map</span><span class="o">.</span><span class="n">real_map_unpadded</span><span class="p">()</span>
<span class="n">site_map_values</span> <span class="o">=</span> <span class="n">flex</span><span class="o">.</span><span class="n">double</span><span class="p">()</span>
<span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">xray_structure</span><span class="o">.</span><span class="n">sites_frac</span><span class="p">()</span> <span class="p">:</span>
  <span class="n">rho</span> <span class="o">=</span> <span class="n">real_map</span><span class="o">.</span><span class="n">eight_point_interpolation</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
  <span class="n">site_map_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
</pre></div>
</div>
<p>As an extreme example of the ease of scripting repetitive actions using
<tt class="docutils literal"><span class="pre">cctbx.miller</span></tt>, here is a complete six-line script to convert all sets of map
coefficients in an MTZ file to sigma-scaled CCP4-format map files (covering the
unit cell):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">iotbx.reflection_file_reader</span> <span class="kn">import</span> <span class="n">any_reflection_file</span>
<span class="n">hkl_in</span> <span class="o">=</span> <span class="n">any_reflection_file</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s">&quot;map_coeffs.mtz&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i_map</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hkl_in</span><span class="o">.</span><span class="n">as_miller_arrays</span><span class="p">())</span> <span class="p">:</span>
  <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">is_complex_array</span><span class="p">()</span> <span class="p">:</span>
    <span class="n">fft_map</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">fft_map</span><span class="p">(</span><span class="n">resolution_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span><span class="o">.</span><span class="n">apply_sigma_scaling</span><span class="p">()</span>
    <span class="n">fft_map</span><span class="o">.</span><span class="n">as_ccp4_map</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="s">&quot;map_</span><span class="si">%d</span><span class="s">.ccp4&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i_map</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>See the documentation for <a class="reference internal" href="cctbx.maptbx.html#module-cctbx.maptbx" title="cctbx.maptbx"><tt class="xref py py-mod docutils literal"><span class="pre">cctbx.maptbx</span></tt></a> for details of working with
map objects.</p>
</div>
<div class="section" id="the-miller-set">
<h2>The Miller set<a class="headerlink" href="#the-miller-set" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cctbx.miller.set">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">set</tt><big>(</big><em>crystal_symmetry</em>, <em>indices</em>, <em>anomalous_flag=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="cctbx.crystal.html#cctbx.crystal.symmetry" title="cctbx.crystal.symmetry"><tt class="xref py py-class docutils literal"><span class="pre">cctbx.crystal.symmetry</span></tt></a></p>
<p>Basic class for handling sets of Miller indices (h,k,l), including sorting
and matching functions, symmetry handling, generation of R-free flags, and
extraction of associated statistics.  Does not actually contain data, but
this can be added using the array(...) method.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.all_selection" title="cctbx.miller.set.all_selection"><tt class="xref py py-obj docutils literal"><span class="pre">all_selection</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.amplitude_normalisations" title="cctbx.miller.set.amplitude_normalisations"><tt class="xref py py-obj docutils literal"><span class="pre">amplitude_normalisations</span></tt></a>(asu_contents,&nbsp;...)</td>
<td>A miller.array whose data N(h) are the normalisations to convert</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.anomalous_flag" title="cctbx.miller.set.anomalous_flag"><tt class="xref py py-obj docutils literal"><span class="pre">anomalous_flag</span></tt></a>()</td>
<td>Indicate whether the set or array is anomalous or not.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.array" title="cctbx.miller.set.array"><tt class="xref py py-obj docutils literal"><span class="pre">array</span></tt></a>([data,&nbsp;sigmas])</td>
<td>Create an array object, given data and/or sigma arrays of identical dimensions to the indices array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.as_anomalous_set" title="cctbx.miller.set.as_anomalous_set"><tt class="xref py py-obj docutils literal"><span class="pre">as_anomalous_set</span></tt></a>()</td>
<td>Return a copy of the set using the same indices but with the anomalous flag set to true.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_cif_block</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.as_non_anomalous_set" title="cctbx.miller.set.as_non_anomalous_set"><tt class="xref py py-obj docutils literal"><span class="pre">as_non_anomalous_set</span></tt></a>()</td>
<td>Return a copy of the set using the same indices but with the anomalous flag set to false.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_py_code</span></tt>([indent])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_reference_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">asu_mappings</span></tt>(buffer_thickness[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.at_first_index" title="cctbx.miller.set.at_first_index"><tt class="xref py py-obj docutils literal"><span class="pre">at_first_index</span></tt></a>(ary,&nbsp;miller_index)</td>
<td>Returns the element <cite>ary</cite> coresponding to the <cite>miller_index</cite> if <a href="#id1"><span class="problematic" id="id2">`</span></a>miller_index exists, otherwise returns None.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.auto_anomalous" title="cctbx.miller.set.auto_anomalous"><tt class="xref py py-obj docutils literal"><span class="pre">auto_anomalous</span></tt></a>([min_n_bijvoet_pairs,&nbsp;...])</td>
<td>Set the anomalous flag automatically depending on whether the data contain Bijvoet pairs (optionally given minimum cutoffs).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">average_b_cart</span></tt>(b_cart)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">average_u_cart</span></tt>(u_cart)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">best_cell</span></tt>([angular_tolerance])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.binner" title="cctbx.miller.set.binner"><tt class="xref py py-obj docutils literal"><span class="pre">binner</span></tt></a>()</td>
<td>Return a reference to the current resolution binner (or None if undefined).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">build_miller_set</span></tt>(anomalous_flag,&nbsp;d_min[,&nbsp;d_max])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">cell_equivalent_p1</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.centric_flags" title="cctbx.miller.set.centric_flags"><tt class="xref py py-obj docutils literal"><span class="pre">centric_flags</span></tt></a>()</td>
<td>Generate a boolean Miller array flagging centric reflections.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.change_basis" title="cctbx.miller.set.change_basis"><tt class="xref py py-obj docutils literal"><span class="pre">change_basis</span></tt></a>(cb_op)</td>
<td>Get a transformation of the miller set with a new basis specified by cb_op</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_best_cell</span></tt>([...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_inverse_hand</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_minimum_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_niggli_cell</span></tt>([...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_primitive_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_reference_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.clear_binner" title="cctbx.miller.set.clear_binner"><tt class="xref py py-obj docutils literal"><span class="pre">clear_binner</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.common_set" title="cctbx.miller.set.common_set"><tt class="xref py py-obj docutils literal"><span class="pre">common_set</span></tt></a>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td>Match the indices in the current set and another set, and return a set (or array) containing only those reflections present in both.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.common_sets" title="cctbx.miller.set.common_sets"><tt class="xref py py-obj docutils literal"><span class="pre">common_sets</span></tt></a>(other[,&nbsp;...])</td>
<td>Like common_set(other), but returns a tuple containing matching copies of both sets (or arrays).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.complete_set" title="cctbx.miller.set.complete_set"><tt class="xref py py-obj docutils literal"><span class="pre">complete_set</span></tt></a>([d_min_tolerance,&nbsp;d_min,&nbsp;...])</td>
<td>Generate the complete set of Miller indices expected for the current symmetry, excepting systematic absences.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.completeness" title="cctbx.miller.set.completeness"><tt class="xref py py-obj docutils literal"><span class="pre">completeness</span></tt></a>([use_binning,&nbsp;d_min_tolerance,&nbsp;...])</td>
<td>Calculate the (fractional) completeness of the array relative to the theoretical complete set, either overall or in resolution bins.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.concatenate" title="cctbx.miller.set.concatenate"><tt class="xref py py-obj docutils literal"><span class="pre">concatenate</span></tt></a>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td>Combine two Miller sets.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.copy" title="cctbx.miller.set.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Create a copy of the set, keeping references to the same crystal symmetry and indices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.crystal_gridding" title="cctbx.miller.set.crystal_gridding"><tt class="xref py py-obj docutils literal"><span class="pre">crystal_gridding</span></tt></a>([resolution_factor,&nbsp;d_min,&nbsp;...])</td>
<td>Calculate real-space grid for FFT given array crystal symmetry, d_min, and desired resolution-dependent spacing.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.crystal_symmetry" title="cctbx.miller.set.crystal_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">crystal_symmetry</span></tt></a>()</td>
<td>Get crystal symmetry of the miller set</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.customized_copy" title="cctbx.miller.set.customized_copy"><tt class="xref py py-obj docutils literal"><span class="pre">customized_copy</span></tt></a>([crystal_symmetry,&nbsp;indices,&nbsp;...])</td>
<td>Create a copy of the set, optionally changing the symmetry, indices, and/or anomalous flag (default = keep all unmodified).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.d_max_min" title="cctbx.miller.set.d_max_min"><tt class="xref py py-obj docutils literal"><span class="pre">d_max_min</span></tt></a>()</td>
<td>Low- and high-resolution limits.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.d_min" title="cctbx.miller.set.d_min"><tt class="xref py py-obj docutils literal"><span class="pre">d_min</span></tt></a>()</td>
<td>High-resolution limit.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.d_min_along_a_b_c_star" title="cctbx.miller.set.d_min_along_a_b_c_star"><tt class="xref py py-obj docutils literal"><span class="pre">d_min_along_a_b_c_star</span></tt></a>()</td>
<td>Returns the effective resolution limits along the reciprocal space axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.d_spacings" title="cctbx.miller.set.d_spacings"><tt class="xref py py-obj docutils literal"><span class="pre">d_spacings</span></tt></a>()</td>
<td>Generate a double Miller array containing the resolution d of each index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.d_star_cubed" title="cctbx.miller.set.d_star_cubed"><tt class="xref py py-obj docutils literal"><span class="pre">d_star_cubed</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.d_star_sq" title="cctbx.miller.set.d_star_sq"><tt class="xref py py-obj docutils literal"><span class="pre">d_star_sq</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.debye_waller_factors" title="cctbx.miller.set.debye_waller_factors"><tt class="xref py py-obj docutils literal"><span class="pre">debye_waller_factors</span></tt></a>([u_iso,&nbsp;b_iso,&nbsp;u_cart,&nbsp;...])</td>
<td>Given an isotropic or anisotropic displacement or B-factor, alculate resolution-dependent scale factors corresponding to the indices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.deep_copy" title="cctbx.miller.set.deep_copy"><tt class="xref py py-obj docutils literal"><span class="pre">deep_copy</span></tt></a>()</td>
<td>Create a copy of the set, also copying the crystal symmetry and indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.delete_index" title="cctbx.miller.set.delete_index"><tt class="xref py py-obj docutils literal"><span class="pre">delete_index</span></tt></a>(hkl)</td>
<td>Remove all reflections with the specified Miller index.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.delete_indices" title="cctbx.miller.set.delete_indices"><tt class="xref py py-obj docutils literal"><span class="pre">delete_indices</span></tt></a>(other)</td>
<td>Delete multiple reflections, as specified by the Miller indices of another set.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">direct_space_asu</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.epsilons" title="cctbx.miller.set.epsilons"><tt class="xref py py-obj docutils literal"><span class="pre">epsilons</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.expand_to_p1" title="cctbx.miller.set.expand_to_p1"><tt class="xref py py-obj docutils literal"><span class="pre">expand_to_p1</span></tt></a>([return_iselection])</td>
<td>Get a transformation of the miller set to spacegroup P1</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.expand_to_p1_iselection" title="cctbx.miller.set.expand_to_p1_iselection"><tt class="xref py py-obj docutils literal"><span class="pre">expand_to_p1_iselection</span></tt></a>([build_iselection])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.f_obs_minus_xray_structure_f_calc" title="cctbx.miller.set.f_obs_minus_xray_structure_f_calc"><tt class="xref py py-obj docutils literal"><span class="pre">f_obs_minus_xray_structure_f_calc</span></tt></a>(...[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.first_index" title="cctbx.miller.set.first_index"><tt class="xref py py-obj docutils literal"><span class="pre">first_index</span></tt></a>(miller_index)</td>
<td>Returns the first index of the item  matching <cite>miller_index</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.generate_r_free_flags" title="cctbx.miller.set.generate_r_free_flags"><tt class="xref py py-obj docutils literal"><span class="pre">generate_r_free_flags</span></tt></a>([fraction,&nbsp;max_free,&nbsp;...])</td>
<td>Create an array of R-free flags for the current set, keeping anomalous pairs together.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.generate_r_free_flags_basic" title="cctbx.miller.set.generate_r_free_flags_basic"><tt class="xref py py-obj docutils literal"><span class="pre">generate_r_free_flags_basic</span></tt></a>([fraction,&nbsp;...])</td>
<td>Generate R-free flags, without taking lattice symmetry into account (not recommended).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.generate_r_free_flags_on_lattice_symmetry" title="cctbx.miller.set.generate_r_free_flags_on_lattice_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">generate_r_free_flags_on_lattice_symmetry</span></tt></a>([...])</td>
<td>Generate R-free flags by converting to the highest possible lattice symmetry (regardless of intensity symmetry), creating flags, and expanding back to the original symmetry.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gridding</span></tt>([d_min,&nbsp;resolution_factor,&nbsp;step,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.index_span" title="cctbx.miller.set.index_span"><tt class="xref py py-obj docutils literal"><span class="pre">index_span</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.indices" title="cctbx.miller.set.indices"><tt class="xref py py-obj docutils literal"><span class="pre">indices</span></tt></a>()</td>
<td>Return a reference to the internal array of indices.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">inverse_hand</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_compatible_unit_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.is_in_asu" title="cctbx.miller.set.is_in_asu"><tt class="xref py py-obj docutils literal"><span class="pre">is_in_asu</span></tt></a>()</td>
<td>Indicate whether the array is entirely contained within the reciprocal space asymmetric unit (ASU).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_patterson_symmetry</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_similar_symmetry</span></tt>(other[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.is_unique_set_under_symmetry" title="cctbx.miller.set.is_unique_set_under_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">is_unique_set_under_symmetry</span></tt></a>()</td>
<td>Determine whether the indices in the set are symmetry-unique.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">join_symmetry</span></tt>(other_symmetry[,&nbsp;force,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.log_binning" title="cctbx.miller.set.log_binning"><tt class="xref py py-obj docutils literal"><span class="pre">log_binning</span></tt></a>([...])</td>
<td>Create resolution bins on a logarithmic scale.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.lone_set" title="cctbx.miller.set.lone_set"><tt class="xref py py-obj docutils literal"><span class="pre">lone_set</span></tt></a>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td>Match the indices in the current set and another set, and return a set (or array) containing reflections which are present only in the current set.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.lone_sets" title="cctbx.miller.set.lone_sets"><tt class="xref py py-obj docutils literal"><span class="pre">lone_sets</span></tt></a>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td>Like lone_set(other), but returns a tuple containing the reflections unique to each set (or array).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.map_to_asu" title="cctbx.miller.set.map_to_asu"><tt class="xref py py-obj docutils literal"><span class="pre">map_to_asu</span></tt></a>()</td>
<td>Convert all indices to lie within the canonical asymmetric unit for the current space group (while preserving anomalous flag).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.match_bijvoet_mates" title="cctbx.miller.set.match_bijvoet_mates"><tt class="xref py py-obj docutils literal"><span class="pre">match_bijvoet_mates</span></tt></a>([...])</td>
<td>Group Bijvoet mates (or Friedel mates) together, returning an object that allows enumeration over matching pairs and/or singletons.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.match_indices" title="cctbx.miller.set.match_indices"><tt class="xref py py-obj docutils literal"><span class="pre">match_indices</span></tt></a>(other[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.miller_indices_as_pdb_file" title="cctbx.miller.set.miller_indices_as_pdb_file"><tt class="xref py py-obj docutils literal"><span class="pre">miller_indices_as_pdb_file</span></tt></a>([file_name,&nbsp;...])</td>
<td>Write out Miller indices as pseudo-waters for visualization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">miller_set</span></tt>(indices,&nbsp;anomalous_flag)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.min_max_d_star_sq" title="cctbx.miller.set.min_max_d_star_sq"><tt class="xref py py-obj docutils literal"><span class="pre">min_max_d_star_sq</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.min_max_indices" title="cctbx.miller.set.min_max_indices"><tt class="xref py py-obj docutils literal"><span class="pre">min_max_indices</span></tt></a>()</td>
<td>Return the range of h,k,l indices</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">minimum_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.minimum_wavelength_based_on_d_min" title="cctbx.miller.set.minimum_wavelength_based_on_d_min"><tt class="xref py py-obj docutils literal"><span class="pre">minimum_wavelength_based_on_d_min</span></tt></a>([tolerance])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.multiplicities" title="cctbx.miller.set.multiplicities"><tt class="xref py py-obj docutils literal"><span class="pre">multiplicities</span></tt></a>()</td>
<td>Generate a Miller array (with integer data) indicating the multiplicity of each unique reflection.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.n_bijvoet_pairs" title="cctbx.miller.set.n_bijvoet_pairs"><tt class="xref py py-obj docutils literal"><span class="pre">n_bijvoet_pairs</span></tt></a>()</td>
<td>Return the number of Bijvoet pairs.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">niggli_cell</span></tt>([relative_epsilon,&nbsp;iteration_limit])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.patterson_symmetry" title="cctbx.miller.set.patterson_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">patterson_symmetry</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">primitive_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.random_phases_compatible_with_phase_restrictions" title="cctbx.miller.set.random_phases_compatible_with_phase_restrictions"><tt class="xref py py-obj docutils literal"><span class="pre">random_phases_compatible_with_phase_restrictions</span></tt></a>([deg])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.reflection_intensity_symmetry" title="cctbx.miller.set.reflection_intensity_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">reflection_intensity_symmetry</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.remove_systematic_absences" title="cctbx.miller.set.remove_systematic_absences"><tt class="xref py py-obj docutils literal"><span class="pre">remove_systematic_absences</span></tt></a>([negate])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.resolution_filter" title="cctbx.miller.set.resolution_filter"><tt class="xref py py-obj docutils literal"><span class="pre">resolution_filter</span></tt></a>([d_max,&nbsp;d_min,&nbsp;negate])</td>
<td>Select a subset within the indicated resolution range.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.resolution_filter_selection" title="cctbx.miller.set.resolution_filter_selection"><tt class="xref py py-obj docutils literal"><span class="pre">resolution_filter_selection</span></tt></a>([d_max,&nbsp;d_min])</td>
<td>Obtain the selection (flex.bool array) corresponding to the specified resolution range.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.resolution_range" title="cctbx.miller.set.resolution_range"><tt class="xref py py-obj docutils literal"><span class="pre">resolution_range</span></tt></a>()</td>
<td>Synonym for d_max_min().</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.select" title="cctbx.miller.set.select"><tt class="xref py py-obj docutils literal"><span class="pre">select</span></tt></a>(selection[,&nbsp;negate,&nbsp;anomalous_flag])</td>
<td>Select a subset of reflections.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.select_acentric" title="cctbx.miller.set.select_acentric"><tt class="xref py py-obj docutils literal"><span class="pre">select_acentric</span></tt></a>()</td>
<td>Select only acentric reflections.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.select_centric" title="cctbx.miller.set.select_centric"><tt class="xref py py-obj docutils literal"><span class="pre">select_centric</span></tt></a>()</td>
<td>Select only centric reflections.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.setup_binner" title="cctbx.miller.set.setup_binner"><tt class="xref py py-obj docutils literal"><span class="pre">setup_binner</span></tt></a>([d_max,&nbsp;d_min,&nbsp;auto_binning,&nbsp;...])</td>
<td>Create internal resolution binner object; required for many other methods to work.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.setup_binner_counting_sorted" title="cctbx.miller.set.setup_binner_counting_sorted"><tt class="xref py py-obj docutils literal"><span class="pre">setup_binner_counting_sorted</span></tt></a>([d_max,&nbsp;d_min,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.setup_binner_d_star_sq_step" title="cctbx.miller.set.setup_binner_d_star_sq_step"><tt class="xref py py-obj docutils literal"><span class="pre">setup_binner_d_star_sq_step</span></tt></a>([auto_binning,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.show_completeness" title="cctbx.miller.set.show_completeness"><tt class="xref py py-obj docutils literal"><span class="pre">show_completeness</span></tt></a>([reflections_per_bin,&nbsp;out])</td>
<td>Display the completeness in resolution bins.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.show_comprehensive_summary" title="cctbx.miller.set.show_comprehensive_summary"><tt class="xref py py-obj docutils literal"><span class="pre">show_comprehensive_summary</span></tt></a>([f,&nbsp;prefix])</td>
<td>Display comprehensive Miller set or array summary</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.show_summary" title="cctbx.miller.set.show_summary"><tt class="xref py py-obj docutils literal"><span class="pre">show_summary</span></tt></a>([f,&nbsp;prefix])</td>
<td>Minimal Miller set summary</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.sin_theta_over_lambda_sq" title="cctbx.miller.set.sin_theta_over_lambda_sq"><tt class="xref py py-obj docutils literal"><span class="pre">sin_theta_over_lambda_sq</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.size" title="cctbx.miller.set.size"><tt class="xref py py-obj docutils literal"><span class="pre">size</span></tt></a>()</td>
<td>Return the number of reflections in the set or array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.slice" title="cctbx.miller.set.slice"><tt class="xref py py-obj docutils literal"><span class="pre">slice</span></tt></a>([axis,&nbsp;axis_index,&nbsp;slice_index,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.sort" title="cctbx.miller.set.sort"><tt class="xref py py-obj docutils literal"><span class="pre">sort</span></tt></a>([by_value,&nbsp;reverse])</td>
<td>Reorder reflections by resolution or Miller index.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.sort_permutation" title="cctbx.miller.set.sort_permutation"><tt class="xref py py-obj docutils literal"><span class="pre">sort_permutation</span></tt></a>([by_value,&nbsp;reverse])</td>
<td>Generate the selection array (flex.size_t object) to reorder the array by resolution or Miller index.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">space_group</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">space_group_info</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">special_position_settings</span></tt>([...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.structure_factors_from_map" title="cctbx.miller.set.structure_factors_from_map"><tt class="xref py py-obj docutils literal"><span class="pre">structure_factors_from_map</span></tt></a>(map[,&nbsp;...])</td>
<td>Run FFT on a real-space map to calculate structure factors corresponding to the current set of Miller indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.structure_factors_from_scatterers" title="cctbx.miller.set.structure_factors_from_scatterers"><tt class="xref py py-obj docutils literal"><span class="pre">structure_factors_from_scatterers</span></tt></a>(xray_structure)</td>
<td>Calculate structure factors for an <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><tt class="xref py py-class docutils literal"><span class="pre">cctbx.xray.structure</span></tt></a> object corresponding to the current set of Miller indices.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">subtract_continuous_allowed_origin_shifts</span></tt>(...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.sys_absent_flags" title="cctbx.miller.set.sys_absent_flags"><tt class="xref py py-obj docutils literal"><span class="pre">sys_absent_flags</span></tt></a>([integral_only])</td>
<td>Generate a boolean Miller array flagging those reflections which are systematically absent under the current symmetry.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.two_theta" title="cctbx.miller.set.two_theta"><tt class="xref py py-obj docutils literal"><span class="pre">two_theta</span></tt></a>(wavelength[,&nbsp;deg])</td>
<td>Generate a double Miller array containing the scattering angle of each index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.unique_under_symmetry" title="cctbx.miller.set.unique_under_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">unique_under_symmetry</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.unique_under_symmetry_selection" title="cctbx.miller.set.unique_under_symmetry_selection"><tt class="xref py py-obj docutils literal"><span class="pre">unique_under_symmetry_selection</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unit_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.use_binner_of" title="cctbx.miller.set.use_binner_of"><tt class="xref py py-obj docutils literal"><span class="pre">use_binner_of</span></tt></a>(other)</td>
<td>Use the exact binner of another set, which must have identical indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.set.use_binning" title="cctbx.miller.set.use_binning"><tt class="xref py py-obj docutils literal"><span class="pre">use_binning</span></tt></a>(binning)</td>
<td>Use the resolution binning of the specified binner object (does not need to be from an identically sized set).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.set.use_binning_of" title="cctbx.miller.set.use_binning_of"><tt class="xref py py-obj docutils literal"><span class="pre">use_binning_of</span></tt></a>(other)</td>
<td>Use the resolution binning of the specified set (does not need to be an identical set of indices).</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cctbx.miller.set.all_selection">
<tt class="descname">all_selection</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.all_selection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.amplitude_normalisations">
<tt class="descname">amplitude_normalisations</tt><big>(</big><em>asu_contents</em>, <em>wilson_plot</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.amplitude_normalisations" title="Permalink to this definition">¶</a></dt>
<dd><p>A miller.array whose data N(h) are the normalisations to convert
between E&#8217;s and F&#8217;s:
E(h) = F(h) / N(h)
The argument wilson_plot shall feature attributes
- wilson_intensity_scale_factor
- wilson_b</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.anomalous_flag">
<tt class="descname">anomalous_flag</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.anomalous_flag" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate whether the set or array is anomalous or not.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.array">
<tt class="descname">array</tt><big>(</big><em>data=None</em>, <em>sigmas=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array object, given data and/or sigma arrays of identical
dimensions to the indices array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; a flex array (any format) or None</li>
<li><strong>sigmas</strong> &#8211; a flex array (any format, but almost always double) or None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.as_anomalous_set">
<tt class="descname">as_anomalous_set</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.as_anomalous_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the set using the same indices but with the anomalous flag
set to true.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.as_non_anomalous_set">
<tt class="descname">as_non_anomalous_set</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.as_non_anomalous_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the set using the same indices but with the anomalous flag
set to false.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.at_first_index">
<tt class="descname">at_first_index</tt><big>(</big><em>ary</em>, <em>miller_index</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.at_first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element <cite>ary</cite> coresponding to the <cite>miller_index</cite> if
<a href="#id3"><span class="problematic" id="id4">`</span></a>miller_index exists, otherwise returns None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>miller_index</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><em>tuple</em></a>) &#8211; Miller index as a 3-tuple</li>
<li><strong>ary</strong> (<em>sequence (list, array, etc)</em>) &#8211; any array (e.g. self.data(), self.sigmas())</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">type of contents of <cite>ary</cite>, or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.auto_anomalous">
<tt class="descname">auto_anomalous</tt><big>(</big><em>min_n_bijvoet_pairs=None</em>, <em>min_fraction_bijvoet_pairs=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.auto_anomalous" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the anomalous flag automatically depending on whether the data
contain Bijvoet pairs (optionally given minimum cutoffs).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a copy of the set with (maybe) a new anomalous flag</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.binner">
<tt class="descname">binner</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.binner" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the current resolution binner (or None if undefined).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.centric_flags">
<tt class="descname">centric_flags</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.centric_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a boolean Miller array flagging centric reflections.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.change_basis">
<tt class="descname">change_basis</tt><big>(</big><em>cb_op</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.change_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transformation of the miller set with a new basis specified by cb_op</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cb_op</strong> (<em>string or sgtbx.change_of_basis_operator</em>) &#8211; object describing the desired transformation of the basis</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a new miller set with the new basis</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">cctbx.miller.set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.clear_binner">
<tt class="descname">clear_binner</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.clear_binner" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.common_set">
<tt class="descname">common_set</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.common_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the indices in the current set and another set, and return a set
(or array) containing only those reflections present in both.  Assumes that
both sets are already in the asymmetric unit (ASU).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.common_sets">
<tt class="descname">common_sets</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em>, <em>assert_no_singles=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.common_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Like common_set(other), but returns a tuple containing matching copies of
both sets (or arrays).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.complete_set">
<tt class="descname">complete_set</tt><big>(</big><em>d_min_tolerance=1e-06</em>, <em>d_min=None</em>, <em>d_max=None</em>, <em>max_index=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.complete_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the complete set of Miller indices expected for the current
symmetry, excepting systematic absences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d_min_tolerance</strong> &#8211; tolerance factor for d_min (avoid precision errors)</li>
<li><strong>d_min</strong> &#8211; High-resolution limit (default = d_min of current set)</li>
<li><strong>d_max</strong> &#8211; Low-resolution limit (default = d_max of current set)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.completeness">
<tt class="descname">completeness</tt><big>(</big><em>use_binning=False</em>, <em>d_min_tolerance=1e-06</em>, <em>return_fail=None</em>, <em>d_max=None</em>, <em>multiplier=1</em>, <em>as_non_anomalous_array=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the (fractional) completeness of the array relative to the
theoretical complete set, either overall or in resolution bins.  By default
the current low-resolution limit will be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d_min_tolerance</strong> &#8211; tolerance factor for d_min (avoid precision errors)</li>
<li><strong>d_max</strong> &#8211; Low-resolution limit (default = d_max of current set)</li>
<li><strong>multiplier</strong> &#8211; Factor to multiply the result by (usually 1 or 100)</li>
<li><strong>as_non_anomalous_array</strong> &#8211; Report values for non-anomalous array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.concatenate">
<tt class="descname">concatenate</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two Miller sets.  Both must have the same anomalous flag, and
similar symmetry is also assumed.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the set, keeping references to the same crystal symmetry
and indices.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.crystal_gridding">
<tt class="descname">crystal_gridding</tt><big>(</big><em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>grid_step=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.crystal_gridding" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate real-space grid for FFT given array crystal symmetry, d_min, and
desired resolution-dependent spacing.  The actual grid dimensions will be
adjusted to suit the needs of the FFT algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.crystal_symmetry">
<tt class="descname">crystal_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.crystal_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get crystal symmetry of the miller set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new crystal.symmetry object</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">cctbx.crystal.symmetry</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.customized_copy">
<tt class="descname">customized_copy</tt><big>(</big><em>crystal_symmetry=Keep</em>, <em>indices=Keep</em>, <em>anomalous_flag=Keep</em>, <em>unit_cell=Keep</em>, <em>space_group_info=Keep</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.customized_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the set, optionally changing the symmetry, indices,
and/or anomalous flag (default = keep all unmodified).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_max_min">
<tt class="descname">d_max_min</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.d_max_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Low- and high-resolution limits.
:returns: Python tuple of floats</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_min">
<tt class="descname">d_min</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.d_min" title="Permalink to this definition">¶</a></dt>
<dd><p>High-resolution limit.
:returns: Python float</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_min_along_a_b_c_star">
<tt class="descname">d_min_along_a_b_c_star</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.d_min_along_a_b_c_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the effective resolution limits along the reciprocal space axes.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_spacings">
<tt class="descname">d_spacings</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.d_spacings" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a double Miller array containing the resolution d of each
index.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_star_cubed">
<tt class="descname">d_star_cubed</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.d_star_cubed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.d_star_sq">
<tt class="descname">d_star_sq</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.d_star_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.debye_waller_factors">
<tt class="descname">debye_waller_factors</tt><big>(</big><em>u_iso=None</em>, <em>b_iso=None</em>, <em>u_cart=None</em>, <em>b_cart=None</em>, <em>u_cif=None</em>, <em>u_star=None</em>, <em>exp_arg_limit=50</em>, <em>truncate_exp_arg=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.debye_waller_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an isotropic or anisotropic displacement or B-factor, alculate
resolution-dependent scale factors corresponding to the indices.
(Note that to simply apply one of the input parameters to an existing
Miller array, you can call array.apply_debye_waller_factors)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u_iso</strong> &#8211; Isotropic displacement (in Angstroms)</li>
<li><strong>b_iso</strong> &#8211; Isotropic B-factor (8*pi^2*u_iso^2)</li>
<li><strong>u_cart</strong> &#8211; Anisotropic displacement tensor</li>
<li><strong>b_cart</strong> &#8211; Anisotropic B-factor</li>
<li><strong>u_star</strong> &#8211; Anisotropic displacement tensor in fractional space</li>
<li><strong>u_cif</strong> &#8211; Anisotropic displacement tensor, dimensionless basis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cctbx.miller.array object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.deep_copy">
<tt class="descname">deep_copy</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the set, also copying the crystal symmetry and indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a set object with all-new attributes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.delete_index">
<tt class="descname">delete_index</tt><big>(</big><em>hkl</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.delete_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all reflections with the specified Miller index.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.delete_indices">
<tt class="descname">delete_indices</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.delete_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete multiple reflections, as specified by the Miller indices of
another set.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.epsilons">
<tt class="descname">epsilons</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.epsilons" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.expand_to_p1">
<tt class="descname">expand_to_p1</tt><big>(</big><em>return_iselection=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.expand_to_p1" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transformation of the miller set to spacegroup P1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new set of parameters (symmetry, miller indices, anomalous_flag) in spacegroup P1</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">set(cctbx.crystal.symmetry, cctbx.miller.indices, boolean)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.expand_to_p1_iselection">
<tt class="descname">expand_to_p1_iselection</tt><big>(</big><em>build_iselection=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.expand_to_p1_iselection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.f_obs_minus_xray_structure_f_calc">
<tt class="descname">f_obs_minus_xray_structure_f_calc</tt><big>(</big><em>f_obs_factor</em>, <em>xray_structure</em>, <em>structure_factor_algorithm=None</em>, <em>cos_sin_table=False</em>, <em>quality_factor=None</em>, <em>u_base=None</em>, <em>b_base=None</em>, <em>wing_cutoff=None</em>, <em>exp_table_one_over_step_size=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.f_obs_minus_xray_structure_f_calc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.first_index">
<tt class="descname">first_index</tt><big>(</big><em>miller_index</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first index of the item  matching
<cite>miller_index</cite>. If the <cite>miller_index</cite> is not found in <cite>self</cite>,
then returns <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>miller_index</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><em>tuple</em></a>) &#8211; Miller index as a 3-tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">int, None &#8211; index of first occurrence of
<cite>miller_index</cite> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.generate_r_free_flags">
<tt class="descname">generate_r_free_flags</tt><big>(</big><em>fraction=0.1</em>, <em>max_free=2000</em>, <em>lattice_symmetry_max_delta=5.0</em>, <em>use_lattice_symmetry=True</em>, <em>use_dataman_shells=False</em>, <em>n_shells=20</em>, <em>format='cns'</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.generate_r_free_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an array of R-free flags for the current set, keeping anomalous
pairs together.  Requires that the set already be unique under symmetry,
and generally assumes that the set is in the ASU.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fraction</strong> &#8211; fraction of reflections to flag for the test set</li>
<li><strong>max_free</strong> &#8211; limit on size of test set, overrides fraction</li>
<li><strong>lattice_symmetry_max_delta</strong> &#8211; limit on lattice symmetry calculation</li>
<li><strong>use_lattice_symmetry</strong> &#8211; given the current symmetry, determine the     highest possible lattice symmetry and generate flags for that symmetry,     then expand to the current (lower) symmetry if necessary.  This is almost     always a good idea.</li>
<li><strong>use_dataman_shells</strong> &#8211; generate flags in thin resolution shells to     avoid bias due to non-crystallographic symmetry.</li>
<li><strong>n_shells</strong> &#8211; number of resolution shells if use_dataman_shells=True</li>
<li><strong>format</strong> &#8211; convention of the resulting flags.  &#8216;cns&#8217; will return a     boolean array (True = free), &#8216;ccp4&#8217; will return an integer array from     0 to X (0 = free, X dependent on fraction), &#8216;shelx&#8217; will return an     integer array with values 1 (work) or -1 (free).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a boolean or integer Miller array, depending on format.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.generate_r_free_flags_basic">
<tt class="descname">generate_r_free_flags_basic</tt><big>(</big><em>fraction=0.1</em>, <em>max_free=2000</em>, <em>use_dataman_shells=False</em>, <em>n_shells=20</em>, <em>format='cns'</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.generate_r_free_flags_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate R-free flags, without taking lattice symmetry into account (not
recommended).  Should not normally be called directly - use
generate_r_free_flags(...) instead.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.generate_r_free_flags_on_lattice_symmetry">
<tt class="descname">generate_r_free_flags_on_lattice_symmetry</tt><big>(</big><em>fraction=0.1</em>, <em>max_free=2000</em>, <em>max_delta=5.0</em>, <em>return_integer_array=False</em>, <em>n_partitions=None</em>, <em>use_dataman_shells=False</em>, <em>n_shells=20</em>, <em>format='cns'</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.generate_r_free_flags_on_lattice_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate R-free flags by converting to the highest possible lattice
symmetry (regardless of intensity symmetry), creating flags, and expanding
back to the original symmetry.  This is a safeguard against reflections
that are correlated due to twinning being split between the work and test
sets.</p>
<p>This method should usually not be called directly, but rather through
set.generate_r_free_flags(...).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.index_span">
<tt class="descname">index_span</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.index_span" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.indices">
<tt class="descname">indices</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a reference to the internal array of indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a cctbx.array_family.flex.miller_index array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.is_in_asu">
<tt class="descname">is_in_asu</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.is_in_asu" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate whether the array is entirely contained within the reciprocal
space asymmetric unit (ASU).  Warning: this calls map_to_asu internally,
so it is better to simply call map_to_asu without checking in many cases.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.is_unique_set_under_symmetry">
<tt class="descname">is_unique_set_under_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.is_unique_set_under_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the indices in the set are symmetry-unique.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.log_binning">
<tt class="descname">log_binning</tt><big>(</big><em>n_reflections_in_lowest_resolution_bin=100</em>, <em>eps=0.0001</em>, <em>max_number_of_bins=30</em>, <em>min_reflections_in_bin=50</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.log_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Create resolution bins on a logarithmic scale.  See Urzhumtsev et al.
(2009) Acta Crystallogr D Biol Crystallogr. 65:1283-91.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.lone_set">
<tt class="descname">lone_set</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.lone_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Match the indices in the current set and another set, and return a set
(or array) containing reflections which are present only in the current
set.  Assumes that both sets are already in the asymmetric unit.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.lone_sets">
<tt class="descname">lone_sets</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.lone_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Like lone_set(other), but returns a tuple containing the reflections
unique to each set (or array).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.map_to_asu">
<tt class="descname">map_to_asu</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.map_to_asu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all indices to lie within the canonical asymmetric unit for the
current space group (while preserving anomalous flag).  Required for many
downstream steps.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.match_bijvoet_mates">
<tt class="descname">match_bijvoet_mates</tt><big>(</big><em>assert_is_unique_set_under_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.match_bijvoet_mates" title="Permalink to this definition">¶</a></dt>
<dd><p>Group Bijvoet mates (or Friedel mates) together, returning an object that
allows enumeration over matching pairs and/or singletons.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.match_indices">
<tt class="descname">match_indices</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.match_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.miller_indices_as_pdb_file">
<tt class="descname">miller_indices_as_pdb_file</tt><big>(</big><em>file_name=None</em>, <em>expand_to_p1=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.miller_indices_as_pdb_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out Miller indices as pseudo-waters for visualization.  Note that
this treats the indices as literal coordinates (times a scale factor),
and the distances between points will not correspond to the distances
in reciprocal space.</p>
<p>See cctbx/miller/display.py and crys3d/hklview for an alternative (but
less lightweight) approach.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.min_max_d_star_sq">
<tt class="descname">min_max_d_star_sq</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.min_max_d_star_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.min_max_indices">
<tt class="descname">min_max_indices</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.min_max_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the range of h,k,l indices</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.minimum_wavelength_based_on_d_min">
<tt class="descname">minimum_wavelength_based_on_d_min</tt><big>(</big><em>tolerance=0.01</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.minimum_wavelength_based_on_d_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.multiplicities">
<tt class="descname">multiplicities</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.multiplicities" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a Miller array (with integer data) indicating the multiplicity of
each unique reflection.  (If the set or array is already symmetry-unique,
the multiplicity will be 1 for every reflection.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">array object with flex.int data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.n_bijvoet_pairs">
<tt class="descname">n_bijvoet_pairs</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.n_bijvoet_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of Bijvoet pairs.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.patterson_symmetry">
<tt class="descname">patterson_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.patterson_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.random_phases_compatible_with_phase_restrictions">
<tt class="descname">random_phases_compatible_with_phase_restrictions</tt><big>(</big><em>deg=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.random_phases_compatible_with_phase_restrictions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.reflection_intensity_symmetry">
<tt class="descname">reflection_intensity_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.reflection_intensity_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.remove_systematic_absences">
<tt class="descname">remove_systematic_absences</tt><big>(</big><em>negate=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.remove_systematic_absences" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.resolution_filter">
<tt class="descname">resolution_filter</tt><big>(</big><em>d_max=0</em>, <em>d_min=0</em>, <em>negate=0</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.resolution_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a subset within the indicated resolution range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d_max</strong> &#8211; Low-resolution cutoff</li>
<li><strong>d_min</strong> &#8211; High-resolution cutoff</li>
<li><strong>negate</strong> &#8211; Select outside this range instead</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">set or array depending on object type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.resolution_filter_selection">
<tt class="descname">resolution_filter_selection</tt><big>(</big><em>d_max=None</em>, <em>d_min=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.resolution_filter_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the selection (flex.bool array) corresponding to the specified
resolution range.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.resolution_range">
<tt class="descname">resolution_range</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.resolution_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for d_max_min().</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.select">
<tt class="descname">select</tt><big>(</big><em>selection</em>, <em>negate=False</em>, <em>anomalous_flag=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a subset of reflections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>selection</strong> &#8211; flex.bool or flex.size_t selection</li>
<li><strong>negate</strong> &#8211; select the inverse of the selection array</li>
<li><strong>anomalous_flag</strong> &#8211; anomalous flag for the new set</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new set with a subset of indices</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.select_acentric">
<tt class="descname">select_acentric</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.select_acentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only acentric reflections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Miller set or array (depending on object type).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.select_centric">
<tt class="descname">select_centric</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.select_centric" title="Permalink to this definition">¶</a></dt>
<dd><p>Select only centric reflections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Miller set or array (depending on object type).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.setup_binner">
<tt class="descname">setup_binner</tt><big>(</big><em>d_max=0</em>, <em>d_min=0</em>, <em>auto_binning=False</em>, <em>reflections_per_bin=0</em>, <em>n_bins=0</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.setup_binner" title="Permalink to this definition">¶</a></dt>
<dd><p>Create internal resolution binner object; required for many other methods
to work.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.setup_binner_counting_sorted">
<tt class="descname">setup_binner_counting_sorted</tt><big>(</big><em>d_max=0</em>, <em>d_min=0</em>, <em>reflections_per_bin=None</em>, <em>d_tolerance=1e-10</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.setup_binner_counting_sorted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.setup_binner_d_star_sq_step">
<tt class="descname">setup_binner_d_star_sq_step</tt><big>(</big><em>auto_binning=True</em>, <em>d_max=None</em>, <em>d_min=None</em>, <em>d_star_sq_step=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.setup_binner_d_star_sq_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.show_completeness">
<tt class="descname">show_completeness</tt><big>(</big><em>reflections_per_bin=500</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.show_completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the completeness in resolution bins.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.show_comprehensive_summary">
<tt class="descname">show_comprehensive_summary</tt><big>(</big><em>f=None</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.show_comprehensive_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Display comprehensive Miller set or array summary</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.show_summary">
<tt class="descname">show_summary</tt><big>(</big><em>f=None</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.show_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimal Miller set summary</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sin_theta_over_lambda_sq">
<tt class="descname">sin_theta_over_lambda_sq</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.sin_theta_over_lambda_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.size">
<tt class="descname">size</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of reflections in the set or array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.slice">
<tt class="descname">slice</tt><big>(</big><em>axis=None</em>, <em>axis_index=None</em>, <em>slice_index=None</em>, <em>slice_start=None</em>, <em>slice_end=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.slice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sort">
<tt class="descname">sort</tt><big>(</big><em>by_value='resolution'</em>, <em>reverse=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder reflections by resolution or Miller index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>by_value</strong> &#8211; &#8216;resolution&#8217; or &#8216;packed_indices&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sort_permutation">
<tt class="descname">sort_permutation</tt><big>(</big><em>by_value='resolution'</em>, <em>reverse=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.sort_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the selection array (flex.size_t object) to reorder the array
by resolution or Miller index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>by_value</strong> &#8211; sort type, must be &#8220;resolution&#8221; or &#8220;packed_indices&#8221;</li>
<li><strong>reverse</strong> &#8211; invert order</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">flex.size_t object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.structure_factors_from_map">
<tt class="descname">structure_factors_from_map</tt><big>(</big><em>map</em>, <em>in_place_fft=False</em>, <em>use_scale=False</em>, <em>anomalous_flag=None</em>, <em>use_sg=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.structure_factors_from_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Run FFT on a real-space map to calculate structure factors corresponding to
the current set of Miller indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>map</strong> &#8211; flex.double map with 3D flex.grid accessor</li>
<li><strong>in_place_fft</strong> &#8211; perform the FFT in place instead of creating a copy of
the map first</li>
<li><strong>use_scale</strong> &#8211; perform volume-scaling using current unit cell</li>
<li><strong>anomalous_flag</strong> &#8211; determines anomalous_flag for output array</li>
<li><strong>use_sg</strong> &#8211; use space-group symmetry</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array with same Miller indices and complex_double data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.structure_factors_from_scatterers">
<tt class="descname">structure_factors_from_scatterers</tt><big>(</big><em>xray_structure</em>, <em>algorithm=None</em>, <em>cos_sin_table=False</em>, <em>grid_resolution_factor=0.3333333333333333</em>, <em>quality_factor=None</em>, <em>u_base=None</em>, <em>b_base=None</em>, <em>wing_cutoff=None</em>, <em>exp_table_one_over_step_size=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.structure_factors_from_scatterers" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate structure factors for an <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><tt class="xref py py-class docutils literal"><span class="pre">cctbx.xray.structure</span></tt></a> object
corresponding to the current set of Miller indices.  Can use either FFT
or direct summation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xray_structure</strong> &#8211; <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><tt class="xref py py-class docutils literal"><span class="pre">cctbx.xray.structure</span></tt></a> object</li>
<li><strong>algorithm</strong> &#8211; switch method to calculate structure factors - can be
&#8216;direct&#8217; or &#8216;fft&#8217;</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array with same Miller indices and complex_double data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.sys_absent_flags">
<tt class="descname">sys_absent_flags</tt><big>(</big><em>integral_only=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.sys_absent_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a boolean Miller array flagging those reflections which are
systematically absent under the current symmetry.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.two_theta">
<tt class="descname">two_theta</tt><big>(</big><em>wavelength</em>, <em>deg=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.two_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a double Miller array containing the scattering angle of each
index.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.unique_under_symmetry">
<tt class="descname">unique_under_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.unique_under_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.unique_under_symmetry_selection">
<tt class="descname">unique_under_symmetry_selection</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.set.unique_under_symmetry_selection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.use_binner_of">
<tt class="descname">use_binner_of</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.use_binner_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the exact binner of another set, which must have identical indices.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.use_binning">
<tt class="descname">use_binning</tt><big>(</big><em>binning</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.use_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the resolution binning of the specified binner object (does not need
to be from an identically sized set).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.set.use_binning_of">
<tt class="descname">use_binning_of</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#cctbx.miller.set.use_binning_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the resolution binning of the specified set (does not need to be an
identical set of indices).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cctbx.miller.build_set">
<tt class="descclassname">cctbx.miller.</tt><tt class="descname">build_set</tt><big>(</big><em>crystal_symmetry</em>, <em>anomalous_flag</em>, <em>d_min=None</em>, <em>d_max=None</em>, <em>max_index=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.build_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Given crystal symmetry, anomalous flag, and resolution limits, create a
complete set object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>crystal_symmetry</strong> &#8211; cctbx.crystal.symmetry object</li>
<li><strong>anomalous_flag</strong> &#8211; Boolean, indicates whether to generate anomalous indices</li>
<li><strong>d_min</strong> &#8211; High-resolution limit (optional if max_index is specified)</li>
<li><strong>d_max</strong> &#8211; Low-resolution limit (optional)</li>
<li><strong>max_index</strong> &#8211; highest-resolution Miller index</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a set object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="the-miller-array">
<h2>The Miller array<a class="headerlink" href="#the-miller-array" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cctbx.miller.array">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">array</tt><big>(</big><em>miller_set</em>, <em>data=None</em>, <em>sigmas=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cctbx.miller.set" title="cctbx.miller.set"><tt class="xref py py-class docutils literal"><span class="pre">cctbx.miller.set</span></tt></a></p>
<p>Extension of the set class with addition of data and (optional) sigmas
flex arrays, plus an optional array_info object and an optional flag for
the observation type (amplitude, intensity, or reconstructed amplitude).</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.adopt_set" title="cctbx.miller.array.adopt_set"><tt class="xref py py-obj docutils literal"><span class="pre">adopt_set</span></tt></a>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">all_selection</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.amplitude_normalisations" title="cctbx.miller.array.amplitude_normalisations"><tt class="xref py py-obj docutils literal"><span class="pre">amplitude_normalisations</span></tt></a>(asu_contents[,&nbsp;...])</td>
<td>Overriden version of set.amplitude_normalisation which computes the Wilson parameters from the array data if wilson_plot is None.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.amplitude_quasi_normalisations" title="cctbx.miller.array.amplitude_quasi_normalisations"><tt class="xref py py-obj docutils literal"><span class="pre">amplitude_quasi_normalisations</span></tt></a>([d_star_power])</td>
<td>A miller.array whose data N(h) are the normalisations to convert</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.amplitudes" title="cctbx.miller.array.amplitudes"><tt class="xref py py-obj docutils literal"><span class="pre">amplitudes</span></tt></a>()</td>
<td>For a complex array, return array of absolute values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.analyze_intensity_statistics" title="cctbx.miller.array.analyze_intensity_statistics"><tt class="xref py py-obj docutils literal"><span class="pre">analyze_intensity_statistics</span></tt></a>([d_min,&nbsp;...])</td>
<td>Detect translational pseudosymmetry and twinning, using methods in Xtriage.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.anomalous_completeness" title="cctbx.miller.array.anomalous_completeness"><tt class="xref py py-obj docutils literal"><span class="pre">anomalous_completeness</span></tt></a>([use_binning,&nbsp;...])</td>
<td>Return the percent of acenric reflections with both h,k,l and -h,-k,-l observed (only meaningful for amplitude and intensity arrays).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.anomalous_differences" title="cctbx.miller.array.anomalous_differences"><tt class="xref py py-obj docutils literal"><span class="pre">anomalous_differences</span></tt></a>([enforce_positive_sigmas])</td>
<td>Returns an array object with DANO (i.e.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anomalous_flag</span></tt>()</td>
<td>Indicate whether the set or array is anomalous or not.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.anomalous_signal" title="cctbx.miller.array.anomalous_signal"><tt class="xref py py-obj docutils literal"><span class="pre">anomalous_signal</span></tt></a>([use_binning])</td>
<td>Get the anomalous signal according to this formula:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.apply_change_of_basis" title="cctbx.miller.array.apply_change_of_basis"><tt class="xref py py-obj docutils literal"><span class="pre">apply_change_of_basis</span></tt></a>(change_of_basis[,&nbsp;...])</td>
<td>Encapsulates a variety of reindexing operations, including handling for a variety of corner cases.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.apply_debye_waller_factors" title="cctbx.miller.array.apply_debye_waller_factors"><tt class="xref py py-obj docutils literal"><span class="pre">apply_debye_waller_factors</span></tt></a>([u_iso,&nbsp;b_iso,&nbsp;...])</td>
<td>Given an isotropic or anisotropic displacement or B-factor, apply resolution-dependent scale factors to the data (and optionally sigmas).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.apply_scaling" title="cctbx.miller.array.apply_scaling"><tt class="xref py py-obj docutils literal"><span class="pre">apply_scaling</span></tt></a>([target_max,&nbsp;factor])</td>
<td>Apply a scale factor to the data (and optionally sigmas).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.apply_shelxl_extinction_correction" title="cctbx.miller.array.apply_shelxl_extinction_correction"><tt class="xref py py-obj docutils literal"><span class="pre">apply_shelxl_extinction_correction</span></tt></a>(x,&nbsp;wavelength)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.arg" title="cctbx.miller.array.arg"><tt class="xref py py-obj docutils literal"><span class="pre">arg</span></tt></a>([deg])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">array</span></tt>([data,&nbsp;sigmas])</td>
<td>Create an array object, given data and/or sigma arrays of identical dimensions to the indices array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.as_amplitude_array" title="cctbx.miller.array.as_amplitude_array"><tt class="xref py py-obj docutils literal"><span class="pre">as_amplitude_array</span></tt></a>([algorithm])</td>
<td>Convert the array to simple amplitudes if not already in that format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.as_anomalous_array" title="cctbx.miller.array.as_anomalous_array"><tt class="xref py py-obj docutils literal"><span class="pre">as_anomalous_array</span></tt></a>()</td>
<td>Return a copy of the array with identical contents (keeping original flex arrays) but with the anomalous flag set to true.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_anomalous_set</span></tt>()</td>
<td>Return a copy of the set using the same indices but with the anomalous flag set to true.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.as_cif_block" title="cctbx.miller.array.as_cif_block"><tt class="xref py py-obj docutils literal"><span class="pre">as_cif_block</span></tt></a>(array_type)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.as_cif_simple" title="cctbx.miller.array.as_cif_simple"><tt class="xref py py-obj docutils literal"><span class="pre">as_cif_simple</span></tt></a>(array_type[,&nbsp;out,&nbsp;data_name])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.as_double" title="cctbx.miller.array.as_double"><tt class="xref py py-obj docutils literal"><span class="pre">as_double</span></tt></a>()</td>
<td>Create a copy of the array with the data converted to a flex.double type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.as_intensity_array" title="cctbx.miller.array.as_intensity_array"><tt class="xref py py-obj docutils literal"><span class="pre">as_intensity_array</span></tt></a>([algorithm])</td>
<td>Convert the array to intensities if not already in that format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.as_mtz_dataset" title="cctbx.miller.array.as_mtz_dataset"><tt class="xref py py-obj docutils literal"><span class="pre">as_mtz_dataset</span></tt></a>(column_root_label[,&nbsp;...])</td>
<td>Generate an iotbx.mtz.dataset object for the array, which can be extended with additional arrays and eventually written to an MTZ file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.as_non_anomalous_array" title="cctbx.miller.array.as_non_anomalous_array"><tt class="xref py py-obj docutils literal"><span class="pre">as_non_anomalous_array</span></tt></a>()</td>
<td>Return a copy of the array with identical contents (keeping original flex arrays) but with the anomalous flag set to false.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_non_anomalous_set</span></tt>()</td>
<td>Return a copy of the set using the same indices but with the anomalous flag set to false.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.as_phases_phs" title="cctbx.miller.array.as_phases_phs"><tt class="xref py py-obj docutils literal"><span class="pre">as_phases_phs</span></tt></a>(out[,&nbsp;scale_amplitudes,&nbsp;...])</td>
<td>Write phases to .phs file.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_py_code</span></tt>([indent])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_reference_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.as_xray_observations" title="cctbx.miller.array.as_xray_observations"><tt class="xref py py-obj docutils literal"><span class="pre">as_xray_observations</span></tt></a>([scale_indices,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">asu_mappings</span></tt>(buffer_thickness[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">at_first_index</span></tt>(ary,&nbsp;miller_index)</td>
<td>Returns the element <cite>ary</cite> coresponding to the <cite>miller_index</cite> if <a href="#id5"><span class="problematic" id="id6">`</span></a>miller_index exists, otherwise returns None.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">auto_anomalous</span></tt>([min_n_bijvoet_pairs,&nbsp;...])</td>
<td>Set the anomalous flag automatically depending on whether the data contain Bijvoet pairs (optionally given minimum cutoffs).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">average_b_cart</span></tt>(b_cart)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.average_bijvoet_mates" title="cctbx.miller.array.average_bijvoet_mates"><tt class="xref py py-obj docutils literal"><span class="pre">average_bijvoet_mates</span></tt></a>()</td>
<td>Given an anomalous array, merge the anomalous pairs and return the non-anomalous average.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">average_u_cart</span></tt>(u_cart)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">best_cell</span></tt>([angular_tolerance])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.bijvoet_ratios" title="cctbx.miller.array.bijvoet_ratios"><tt class="xref py py-obj docutils literal"><span class="pre">bijvoet_ratios</span></tt></a>([obs_type,&nbsp;measurable_only,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">binner</span></tt>()</td>
<td>Return a reference to the current resolution binner (or None if undefined).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">build_miller_set</span></tt>(anomalous_flag,&nbsp;d_min[,&nbsp;d_max])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.cc_anom" title="cctbx.miller.array.cc_anom"><tt class="xref py py-obj docutils literal"><span class="pre">cc_anom</span></tt></a>(*args,&nbsp;**kwds)</td>
<td>Alias for array.half_dataset_anomalous_correlation()</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.cc_one_half" title="cctbx.miller.array.cc_one_half"><tt class="xref py py-obj docutils literal"><span class="pre">cc_one_half</span></tt></a>([use_binning,&nbsp;n_trials,&nbsp;...])</td>
<td>Calculate the correlation between two randomly assigned pools of unmerged data (&#8220;CC 1/2&#8221;).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">cell_equivalent_p1</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">centric_flags</span></tt>()</td>
<td>Generate a boolean Miller array flagging centric reflections.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.change_basis" title="cctbx.miller.array.change_basis"><tt class="xref py py-obj docutils literal"><span class="pre">change_basis</span></tt></a>(cb_op[,&nbsp;deg])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_best_cell</span></tt>([...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_inverse_hand</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_minimum_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_niggli_cell</span></tt>([...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_primitive_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_of_basis_op_to_reference_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.change_symmetry" title="cctbx.miller.array.change_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">change_symmetry</span></tt></a>([space_group_symbol,&nbsp;...])</td>
<td>Encapsulates all operations required to convert the original data to a different symmetry (e.g.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">clear_binner</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.combine" title="cctbx.miller.array.combine"><tt class="xref py py-obj docutils literal"><span class="pre">combine</span></tt></a>(other[,&nbsp;scale,&nbsp;scale_for_lones])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">common_set</span></tt>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td>Match the indices in the current set and another set, and return a set (or array) containing only those reflections present in both.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">common_sets</span></tt>(other[,&nbsp;...])</td>
<td>Like common_set(other), but returns a tuple containing matching copies of both sets (or arrays).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.complete_array" title="cctbx.miller.array.complete_array"><tt class="xref py py-obj docutils literal"><span class="pre">complete_array</span></tt></a>([d_min_tolerance,&nbsp;d_min,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">complete_set</span></tt>([d_min_tolerance,&nbsp;d_min,&nbsp;...])</td>
<td>Generate the complete set of Miller indices expected for the current symmetry, excepting systematic absences.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.complete_with" title="cctbx.miller.array.complete_with"><tt class="xref py py-obj docutils literal"><span class="pre">complete_with</span></tt></a>(other[,&nbsp;scale,&nbsp;replace_phases])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.complete_with_bin_average" title="cctbx.miller.array.complete_with_bin_average"><tt class="xref py py-obj docutils literal"><span class="pre">complete_with_bin_average</span></tt></a>([reflections_per_bin])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">completeness</span></tt>([use_binning,&nbsp;d_min_tolerance,&nbsp;...])</td>
<td>Calculate the (fractional) completeness of the array relative to the theoretical complete set, either overall or in resolution bins.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.concatenate" title="cctbx.miller.array.concatenate"><tt class="xref py py-obj docutils literal"><span class="pre">concatenate</span></tt></a>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.conjugate" title="cctbx.miller.array.conjugate"><tt class="xref py py-obj docutils literal"><span class="pre">conjugate</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.convert_to_non_anomalous_if_ratio_pairs_lone_less_than" title="cctbx.miller.array.convert_to_non_anomalous_if_ratio_pairs_lone_less_than"><tt class="xref py py-obj docutils literal"><span class="pre">convert_to_non_anomalous_if_ratio_pairs_lone_less_than</span></tt></a>(...)</td>
<td>Convert anomalous array into nonanomalous if the number of Bijvoet pairs is too small compared to the number of lone Bijvoet mates.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.copy" title="cctbx.miller.array.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Create a new array object using references to internal objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.correlation" title="cctbx.miller.array.correlation"><tt class="xref py py-obj docutils literal"><span class="pre">correlation</span></tt></a>(other[,&nbsp;use_binning,&nbsp;...])</td>
<td>Calculate correlation coefficient between two arrays (either globally or binned).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.count_and_fraction_in_bins" title="cctbx.miller.array.count_and_fraction_in_bins"><tt class="xref py py-obj docutils literal"><span class="pre">count_and_fraction_in_bins</span></tt></a>(data_value_to_count)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crystal_gridding</span></tt>([resolution_factor,&nbsp;d_min,&nbsp;...])</td>
<td>Calculate real-space grid for FFT given array crystal symmetry, d_min, and desired resolution-dependent spacing.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crystal_symmetry</span></tt>()</td>
<td>Get crystal symmetry of the miller set</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.crystal_symmetry_is_compatible_with_symmetry_from_file" title="cctbx.miller.array.crystal_symmetry_is_compatible_with_symmetry_from_file"><tt class="xref py py-obj docutils literal"><span class="pre">crystal_symmetry_is_compatible_with_symmetry_from_file</span></tt></a>([...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.customized_copy" title="cctbx.miller.array.customized_copy"><tt class="xref py py-obj docutils literal"><span class="pre">customized_copy</span></tt></a>([miller_set,&nbsp;data,&nbsp;sigmas,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_max_min</span></tt>()</td>
<td>Low- and high-resolution limits.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_min</span></tt>()</td>
<td>High-resolution limit.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_min_along_a_b_c_star</span></tt>()</td>
<td>Returns the effective resolution limits along the reciprocal space axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_spacings</span></tt>()</td>
<td>Generate a double Miller array containing the resolution d of each index.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_star_cubed</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_star_sq</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.data" title="cctbx.miller.array.data"><tt class="xref py py-obj docutils literal"><span class="pre">data</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.data_at_first_index" title="cctbx.miller.array.data_at_first_index"><tt class="xref py py-obj docutils literal"><span class="pre">data_at_first_index</span></tt></a>(miller_index)</td>
<td>Returns the value of data of the first index matching <cite>miller_index</cite>.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">debye_waller_factors</span></tt>([u_iso,&nbsp;b_iso,&nbsp;u_cart,&nbsp;...])</td>
<td>Given an isotropic or anisotropic displacement or B-factor, alculate resolution-dependent scale factors corresponding to the indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.deep_copy" title="cctbx.miller.array.deep_copy"><tt class="xref py py-obj docutils literal"><span class="pre">deep_copy</span></tt></a>()</td>
<td>Clone the array, making copies of all internal array objects.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">delete_index</span></tt>(hkl)</td>
<td>Remove all reflections with the specified Miller index.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">delete_indices</span></tt>(other)</td>
<td>Delete multiple reflections, as specified by the Miller indices of another set.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.detwin_data" title="cctbx.miller.array.detwin_data"><tt class="xref py py-obj docutils literal"><span class="pre">detwin_data</span></tt></a>(twin_law,&nbsp;alpha)</td>
<td>Detwin data using a known twin fraction, returning an array with the same original data type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">direct_space_asu</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.direct_summation_at_point" title="cctbx.miller.array.direct_summation_at_point"><tt class="xref py py-obj docutils literal"><span class="pre">direct_summation_at_point</span></tt></a>(site_frac[,&nbsp;sigma])</td>
<td>Calculates the exact map value at the specified fractional coordinate using direct Fourier summation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.disagreeable_reflections" title="cctbx.miller.array.disagreeable_reflections"><tt class="xref py py-obj docutils literal"><span class="pre">disagreeable_reflections</span></tt></a>(f_calc_sq[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.discard_sigmas" title="cctbx.miller.array.discard_sigmas"><tt class="xref py py-obj docutils literal"><span class="pre">discard_sigmas</span></tt></a>()</td>
<td>Create a copy of the array without sigmas.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.double_step_filtration" title="cctbx.miller.array.double_step_filtration"><tt class="xref py py-obj docutils literal"><span class="pre">double_step_filtration</span></tt></a>([complete_set,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.eliminate_sys_absent" title="cctbx.miller.array.eliminate_sys_absent"><tt class="xref py py-obj docutils literal"><span class="pre">eliminate_sys_absent</span></tt></a>([integral_only,&nbsp;log,&nbsp;...])</td>
<td>Remove all reflections which should be systematically absent in the current space group.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.ellipsoidal_resolutions_and_indices_by_sigma" title="cctbx.miller.array.ellipsoidal_resolutions_and_indices_by_sigma"><tt class="xref py py-obj docutils literal"><span class="pre">ellipsoidal_resolutions_and_indices_by_sigma</span></tt></a>([...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.ellipsoidal_truncation_by_sigma" title="cctbx.miller.array.ellipsoidal_truncation_by_sigma"><tt class="xref py py-obj docutils literal"><span class="pre">ellipsoidal_truncation_by_sigma</span></tt></a>([sigma_cutoff])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.enforce_positive_amplitudes" title="cctbx.miller.array.enforce_positive_amplitudes"><tt class="xref py py-obj docutils literal"><span class="pre">enforce_positive_amplitudes</span></tt></a>([i_sig_level])</td>
<td>Takes in an intensity array (including negatives) and spits out amplitudes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.enforce_positive_sigmas" title="cctbx.miller.array.enforce_positive_sigmas"><tt class="xref py py-obj docutils literal"><span class="pre">enforce_positive_sigmas</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">epsilons</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.expand_to_p1" title="cctbx.miller.array.expand_to_p1"><tt class="xref py py-obj docutils literal"><span class="pre">expand_to_p1</span></tt></a>([phase_deg,&nbsp;return_iselection])</td>
<td>Generate the equivalent P1 dataset.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_to_p1_iselection</span></tt>([build_iselection])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.export_as_cns_hkl" title="cctbx.miller.array.export_as_cns_hkl"><tt class="xref py py-obj docutils literal"><span class="pre">export_as_cns_hkl</span></tt></a>(file_object[,&nbsp;file_name,&nbsp;...])</td>
<td>Write reflections to a CNS-format file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.export_as_scalepack_unmerged" title="cctbx.miller.array.export_as_scalepack_unmerged"><tt class="xref py py-obj docutils literal"><span class="pre">export_as_scalepack_unmerged</span></tt></a>([file_object,&nbsp;...])</td>
<td>Write data in unmerged scalepack format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.export_as_shelx_hklf" title="cctbx.miller.array.export_as_shelx_hklf"><tt class="xref py py-obj docutils literal"><span class="pre">export_as_shelx_hklf</span></tt></a>([file_object,&nbsp;...])</td>
<td>Write reflections to a SHELX-format .hkl file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.f_as_f_sq" title="cctbx.miller.array.f_as_f_sq"><tt class="xref py py-obj docutils literal"><span class="pre">f_as_f_sq</span></tt></a>([algorithm])</td>
<td>Convert amplitudes (and associated sigmas, if present) to intensities.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.f_obs_f_calc_fan_outlier_selection" title="cctbx.miller.array.f_obs_f_calc_fan_outlier_selection"><tt class="xref py py-obj docutils literal"><span class="pre">f_obs_f_calc_fan_outlier_selection</span></tt></a>(f_calc[,&nbsp;...])</td>
<td>Preconditions (not checked explicitly): self is amplitude array, f_calc is complex array or amplitude array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.f_obs_minus_f_calc" title="cctbx.miller.array.f_obs_minus_f_calc"><tt class="xref py py-obj docutils literal"><span class="pre">f_obs_minus_f_calc</span></tt></a>(f_obs_factor,&nbsp;f_calc)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">f_obs_minus_xray_structure_f_calc</span></tt>(...[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.f_sq_as_f" title="cctbx.miller.array.f_sq_as_f"><tt class="xref py py-obj docutils literal"><span class="pre">f_sq_as_f</span></tt></a>([algorithm,&nbsp;tolerance])</td>
<td>Given an intensity/F^2 array (or undefined observation type), return the equivalent amplitudes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.fft_map" title="cctbx.miller.array.fft_map"><tt class="xref py py-obj docutils literal"><span class="pre">fft_map</span></tt></a>([resolution_factor,&nbsp;d_min,&nbsp;...])</td>
<td>Calculate the FFT for the array, assuming the data are complex doubles.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">first_index</span></tt>(miller_index)</td>
<td>Returns the first index of the item  matching <cite>miller_index</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.french_wilson" title="cctbx.miller.array.french_wilson"><tt class="xref py py-obj docutils literal"><span class="pre">french_wilson</span></tt></a>(**kwds)</td>
<td>Perform French-Wilson treatment of X-ray intensities to estimate the &#8220;true&#8221; intensities, replacing very weak and/or negative values, and takes the square root to obtain amplitudes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.from_cif" title="cctbx.miller.array.from_cif"><tt class="xref py py-obj docutils literal"><span class="pre">from_cif</span></tt></a>([file_object,&nbsp;file_path,&nbsp;...])</td>
<td>Class method for building an array from a CIF file (or filehandle).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.generate_bijvoet_mates" title="cctbx.miller.array.generate_bijvoet_mates"><tt class="xref py py-obj docutils literal"><span class="pre">generate_bijvoet_mates</span></tt></a>()</td>
<td>If the array is not already anomalous, expand to generate anomalous pairs (without changing data).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">generate_r_free_flags</span></tt>([fraction,&nbsp;max_free,&nbsp;...])</td>
<td>Create an array of R-free flags for the current set, keeping anomalous pairs together.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">generate_r_free_flags_basic</span></tt>([fraction,&nbsp;...])</td>
<td>Generate R-free flags, without taking lattice symmetry into account (not recommended).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">generate_r_free_flags_on_lattice_symmetry</span></tt>([...])</td>
<td>Generate R-free flags by converting to the highest possible lattice symmetry (regardless of intensity symmetry), creating flags, and expanding back to the original symmetry.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gridding</span></tt>([d_min,&nbsp;resolution_factor,&nbsp;step,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.half_dataset_anomalous_correlation" title="cctbx.miller.array.half_dataset_anomalous_correlation"><tt class="xref py py-obj docutils literal"><span class="pre">half_dataset_anomalous_correlation</span></tt></a>([use_binning])</td>
<td>Calculate the correlation of the anomalous differences of two randomly assigned half-datasets (starting from unmerged data).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.has_twinning" title="cctbx.miller.array.has_twinning"><tt class="xref py py-obj docutils literal"><span class="pre">has_twinning</span></tt></a>([d_min])</td>
<td>Convenience method for identifying twinned data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.hemisphere_acentrics" title="cctbx.miller.array.hemisphere_acentrics"><tt class="xref py py-obj docutils literal"><span class="pre">hemisphere_acentrics</span></tt></a>(plus_or_minus)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.hemispheres_acentrics" title="cctbx.miller.array.hemispheres_acentrics"><tt class="xref py py-obj docutils literal"><span class="pre">hemispheres_acentrics</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.hoppe_gassmann_modification" title="cctbx.miller.array.hoppe_gassmann_modification"><tt class="xref py py-obj docutils literal"><span class="pre">hoppe_gassmann_modification</span></tt></a>(mean_scale,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.i_over_sig_i" title="cctbx.miller.array.i_over_sig_i"><tt class="xref py py-obj docutils literal"><span class="pre">i_over_sig_i</span></tt></a>([use_binning,&nbsp;return_fail])</td>
<td>&lt;I/sigma_I&gt;</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">index_span</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indices</span></tt>()</td>
<td>Return a reference to the internal array of indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.info" title="cctbx.miller.array.info"><tt class="xref py py-obj docutils literal"><span class="pre">info</span></tt></a>()</td>
<td>Return the associated info object, or None if undefined.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.intensities" title="cctbx.miller.array.intensities"><tt class="xref py py-obj docutils literal"><span class="pre">intensities</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">inverse_hand</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.is_bool_array" title="cctbx.miller.array.is_bool_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_bool_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_compatible_unit_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.is_complex_array" title="cctbx.miller.array.is_complex_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_complex_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.is_hendrickson_lattman_array" title="cctbx.miller.array.is_hendrickson_lattman_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_hendrickson_lattman_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_in_asu</span></tt>()</td>
<td>Indicate whether the array is entirely contained within the reciprocal space asymmetric unit (ASU).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.is_integer_array" title="cctbx.miller.array.is_integer_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_integer_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_patterson_symmetry</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.is_real_array" title="cctbx.miller.array.is_real_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_real_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_similar_symmetry</span></tt>(other[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.is_string_array" title="cctbx.miller.array.is_string_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_string_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_unique_set_under_symmetry</span></tt>()</td>
<td>Determine whether the indices in the set are symmetry-unique.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.is_unmerged_intensity_array" title="cctbx.miller.array.is_unmerged_intensity_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_unmerged_intensity_array</span></tt></a>()</td>
<td>Determine whether the array contains unmerged experimental observations or not.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.is_xray_amplitude_array" title="cctbx.miller.array.is_xray_amplitude_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_xray_amplitude_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.is_xray_data_array" title="cctbx.miller.array.is_xray_data_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_xray_data_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.is_xray_intensity_array" title="cctbx.miller.array.is_xray_intensity_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_xray_intensity_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.is_xray_reconstructed_amplitude_array" title="cctbx.miller.array.is_xray_reconstructed_amplitude_array"><tt class="xref py py-obj docutils literal"><span class="pre">is_xray_reconstructed_amplitude_array</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">join_symmetry</span></tt>(other_symmetry[,&nbsp;force,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.local_standard_deviation_map" title="cctbx.miller.array.local_standard_deviation_map"><tt class="xref py py-obj docutils literal"><span class="pre">local_standard_deviation_map</span></tt></a>(radius[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">log_binning</span></tt>([...])</td>
<td>Create resolution bins on a logarithmic scale.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">lone_set</span></tt>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td>Match the indices in the current set and another set, and return a set (or array) containing reflections which are present only in the current set.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">lone_sets</span></tt>(other[,&nbsp;assert_is_similar_symmetry])</td>
<td>Like lone_set(other), but returns a tuple containing the reflections unique to each set (or array).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.map_correlation" title="cctbx.miller.array.map_correlation"><tt class="xref py py-obj docutils literal"><span class="pre">map_correlation</span></tt></a>(other)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.map_to_asu" title="cctbx.miller.array.map_to_asu"><tt class="xref py py-obj docutils literal"><span class="pre">map_to_asu</span></tt></a>([deg])</td>
<td>Convert all indices to lie within the canonical asymmetric unit for the current space group (while preserving anomalous flag).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">match_bijvoet_mates</span></tt>([...])</td>
<td>Group Bijvoet mates (or Friedel mates) together, returning an object that allows enumeration over matching pairs and/or singletons.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">match_indices</span></tt>(other[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.matching_set" title="cctbx.miller.array.matching_set"><tt class="xref py py-obj docutils literal"><span class="pre">matching_set</span></tt></a>(other,&nbsp;data_substitute[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.mean" title="cctbx.miller.array.mean"><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></a>([use_binning,&nbsp;use_multiplicities,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.mean_of_intensity_divided_by_epsilon" title="cctbx.miller.array.mean_of_intensity_divided_by_epsilon"><tt class="xref py py-obj docutils literal"><span class="pre">mean_of_intensity_divided_by_epsilon</span></tt></a>([...])</td>
<td>&lt;I/epsilon&gt;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.mean_of_squared_sigma_divided_by_epsilon" title="cctbx.miller.array.mean_of_squared_sigma_divided_by_epsilon"><tt class="xref py py-obj docutils literal"><span class="pre">mean_of_squared_sigma_divided_by_epsilon</span></tt></a>([...])</td>
<td>&lt;sigma^2/epsilon&gt;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.mean_phase_error" title="cctbx.miller.array.mean_phase_error"><tt class="xref py py-obj docutils literal"><span class="pre">mean_phase_error</span></tt></a>(phase_source)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.mean_sq" title="cctbx.miller.array.mean_sq"><tt class="xref py py-obj docutils literal"><span class="pre">mean_sq</span></tt></a>([use_binning,&nbsp;use_multiplicities])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.mean_weighted_phase_error" title="cctbx.miller.array.mean_weighted_phase_error"><tt class="xref py py-obj docutils literal"><span class="pre">mean_weighted_phase_error</span></tt></a>(phase_source)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.measurability" title="cctbx.miller.array.measurability"><tt class="xref py py-obj docutils literal"><span class="pre">measurability</span></tt></a>([use_binning,&nbsp;cutoff,&nbsp;return_fail])</td>
<td>Fraction of reflections for which</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.merge_equivalents" title="cctbx.miller.array.merge_equivalents"><tt class="xref py py-obj docutils literal"><span class="pre">merge_equivalents</span></tt></a>([algorithm,&nbsp;...])</td>
<td>Given a non-unique array, merge the symmetry-related reflections (keeping anomalous flag).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">miller_indices_as_pdb_file</span></tt>([file_name,&nbsp;...])</td>
<td>Write out Miller indices as pseudo-waters for visualization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">miller_set</span></tt>(indices,&nbsp;anomalous_flag)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.min_f_over_sigma" title="cctbx.miller.array.min_f_over_sigma"><tt class="xref py py-obj docutils literal"><span class="pre">min_f_over_sigma</span></tt></a>([return_none_if_zero_sigmas])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">min_max_d_star_sq</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min_max_indices</span></tt>()</td>
<td>Return the range of h,k,l indices</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">minimum_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">minimum_wavelength_based_on_d_min</span></tt>([tolerance])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">multiplicities</span></tt>()</td>
<td>Generate a Miller array (with integer data) indicating the multiplicity of each unique reflection.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.multiscale" title="cctbx.miller.array.multiscale"><tt class="xref py py-obj docutils literal"><span class="pre">multiscale</span></tt></a>(other[,&nbsp;reflections_per_bin])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_bijvoet_pairs</span></tt>()</td>
<td>Return the number of Bijvoet pairs.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">niggli_cell</span></tt>([relative_epsilon,&nbsp;iteration_limit])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.norm" title="cctbx.miller.array.norm"><tt class="xref py py-obj docutils literal"><span class="pre">norm</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.normalised_amplitudes" title="cctbx.miller.array.normalised_amplitudes"><tt class="xref py py-obj docutils literal"><span class="pre">normalised_amplitudes</span></tt></a>(asu_contents[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.normalize" title="cctbx.miller.array.normalize"><tt class="xref py py-obj docutils literal"><span class="pre">normalize</span></tt></a>([reflections_per_bin,&nbsp;eps_fac])</td>
<td>Compute E-values: E = (F/eps**0.5) / rms of (F/eps**0.5) This is &#8216;Karle&#8217; approach, that is not using overall B from Wilson plot.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.observation_type" title="cctbx.miller.array.observation_type"><tt class="xref py py-obj docutils literal"><span class="pre">observation_type</span></tt></a>()</td>
<td>Return the (experimental) data type, if defined.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.patterson_map" title="cctbx.miller.array.patterson_map"><tt class="xref py py-obj docutils literal"><span class="pre">patterson_map</span></tt></a>([resolution_factor,&nbsp;d_min,&nbsp;...])</td>
<td>Calculate an unphased Patterson map.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.patterson_symmetry" title="cctbx.miller.array.patterson_symmetry"><tt class="xref py py-obj docutils literal"><span class="pre">patterson_symmetry</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.permute_d_range" title="cctbx.miller.array.permute_d_range"><tt class="xref py py-obj docutils literal"><span class="pre">permute_d_range</span></tt></a>(d_max,&nbsp;d_min)</td>
<td>Randomly shuffle reflections within a given resolution range.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.phase_entropy" title="cctbx.miller.array.phase_entropy"><tt class="xref py py-obj docutils literal"><span class="pre">phase_entropy</span></tt></a>([exponentiate,&nbsp;...])</td>
<td>Get phase entropy as measured in terms of an base-360 entropy (base-2 for centrics).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.phase_integrals" title="cctbx.miller.array.phase_integrals"><tt class="xref py py-obj docutils literal"><span class="pre">phase_integrals</span></tt></a>([n_steps,&nbsp;integrator])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.phase_transfer" title="cctbx.miller.array.phase_transfer"><tt class="xref py py-obj docutils literal"><span class="pre">phase_transfer</span></tt></a>(phase_source[,&nbsp;epsilon,&nbsp;deg,&nbsp;...])</td>
<td>Combines phases of phase_source with self&#8217;s data if real (keeping the sign of self&#8217;s data) or with self&#8217;s amplitudes if complex.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.phased_translation_function_coeff" title="cctbx.miller.array.phased_translation_function_coeff"><tt class="xref py py-obj docutils literal"><span class="pre">phased_translation_function_coeff</span></tt></a>(...[,&nbsp;fom])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.phases" title="cctbx.miller.array.phases"><tt class="xref py py-obj docutils literal"><span class="pre">phases</span></tt></a>([deg])</td>
<td>For a complex array, return the array of its phases (in radians by default).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">primitive_setting</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.quasi_normalize_structure_factors" title="cctbx.miller.array.quasi_normalize_structure_factors"><tt class="xref py py-obj docutils literal"><span class="pre">quasi_normalize_structure_factors</span></tt></a>([d_star_power])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.quasi_normalized_as_normalized" title="cctbx.miller.array.quasi_normalized_as_normalized"><tt class="xref py py-obj docutils literal"><span class="pre">quasi_normalized_as_normalized</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.r1_factor" title="cctbx.miller.array.r1_factor"><tt class="xref py py-obj docutils literal"><span class="pre">r1_factor</span></tt></a>(other[,&nbsp;scale_factor,&nbsp;...])</td>
<td>Get the R1 factor according to this formula</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.r_anom" title="cctbx.miller.array.r_anom"><tt class="xref py py-obj docutils literal"><span class="pre">r_anom</span></tt></a>()</td>
<td>Calculate R_anom, which measures the agreement between Friedel mates.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.r_free_flags_accumulation" title="cctbx.miller.array.r_free_flags_accumulation"><tt class="xref py py-obj docutils literal"><span class="pre">r_free_flags_accumulation</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">random_phases_compatible_with_phase_restrictions</span></tt>([deg])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.randomize_amplitude_and_phase" title="cctbx.miller.array.randomize_amplitude_and_phase"><tt class="xref py py-obj docutils literal"><span class="pre">randomize_amplitude_and_phase</span></tt></a>(...[,&nbsp;...])</td>
<td>Add random error to reflections.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.randomize_phases" title="cctbx.miller.array.randomize_phases"><tt class="xref py py-obj docutils literal"><span class="pre">randomize_phases</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reflection_intensity_symmetry</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.remove_cone" title="cctbx.miller.array.remove_cone"><tt class="xref py py-obj docutils literal"><span class="pre">remove_cone</span></tt></a>(fraction_percent[,&nbsp;vertex,&nbsp;...])</td>
<td>Remove reflections corresponding to a cone shape in reciprocal space with the apex at the origin.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.remove_patterson_origin_peak" title="cctbx.miller.array.remove_patterson_origin_peak"><tt class="xref py py-obj docutils literal"><span class="pre">remove_patterson_origin_peak</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_systematic_absences</span></tt>([negate])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">resolution_filter</span></tt>([d_max,&nbsp;d_min,&nbsp;negate])</td>
<td>Select a subset within the indicated resolution range.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">resolution_filter_selection</span></tt>([d_max,&nbsp;d_min])</td>
<td>Obtain the selection (flex.bool array) corresponding to the specified resolution range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">resolution_range</span></tt>()</td>
<td>Synonym for d_max_min().</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.rms" title="cctbx.miller.array.rms"><tt class="xref py py-obj docutils literal"><span class="pre">rms</span></tt></a>([use_binning,&nbsp;use_multiplicities])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.rms_filter" title="cctbx.miller.array.rms_filter"><tt class="xref py py-obj docutils literal"><span class="pre">rms_filter</span></tt></a>(cutoff_factor[,&nbsp;use_binning,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.scale" title="cctbx.miller.array.scale"><tt class="xref py py-obj docutils literal"><span class="pre">scale</span></tt></a>(other[,&nbsp;resolution_dependent])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.scale_factor" title="cctbx.miller.array.scale_factor"><tt class="xref py py-obj docutils literal"><span class="pre">scale_factor</span></tt></a>(f_calc[,&nbsp;weights,&nbsp;...])</td>
<td>The analytical expression for the least squares scale factor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.second_moment" title="cctbx.miller.array.second_moment"><tt class="xref py py-obj docutils literal"><span class="pre">second_moment</span></tt></a>([use_binning])</td>
<td>&lt;data^2&gt;/(&lt;data&gt;)^2</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.second_moment_of_intensities" title="cctbx.miller.array.second_moment_of_intensities"><tt class="xref py py-obj docutils literal"><span class="pre">second_moment_of_intensities</span></tt></a>([use_binning])</td>
<td>&lt;I^2&gt;/(&lt;I&gt;)^2 (2.0 for untwinned, 1.5 for twinned data)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.second_moments_centric_acentric" title="cctbx.miller.array.second_moments_centric_acentric"><tt class="xref py py-obj docutils literal"><span class="pre">second_moments_centric_acentric</span></tt></a>([...])</td>
<td>Compute &lt;E**4&gt;/&lt;E**2&gt;**2 for centric and acentric reflections.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.select" title="cctbx.miller.array.select"><tt class="xref py py-obj docutils literal"><span class="pre">select</span></tt></a>(selection[,&nbsp;negate,&nbsp;anomalous_flag])</td>
<td>Select a sub-array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">select_acentric</span></tt>()</td>
<td>Select only acentric reflections.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">select_centric</span></tt>()</td>
<td>Select only centric reflections.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.select_indices" title="cctbx.miller.array.select_indices"><tt class="xref py py-obj docutils literal"><span class="pre">select_indices</span></tt></a>(indices[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.select_sys_absent" title="cctbx.miller.array.select_sys_absent"><tt class="xref py py-obj docutils literal"><span class="pre">select_sys_absent</span></tt></a>([integral_only])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.set" title="cctbx.miller.array.set"><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt></a>([crystal_symmetry,&nbsp;indices,&nbsp;...])</td>
<td>Return the basic cctbx.miller.set object for the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.set_info" title="cctbx.miller.array.set_info"><tt class="xref py py-obj docutils literal"><span class="pre">set_info</span></tt></a>(info)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.set_observation_type" title="cctbx.miller.array.set_observation_type"><tt class="xref py py-obj docutils literal"><span class="pre">set_observation_type</span></tt></a>(observation_type)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.set_observation_type_xray_amplitude" title="cctbx.miller.array.set_observation_type_xray_amplitude"><tt class="xref py py-obj docutils literal"><span class="pre">set_observation_type_xray_amplitude</span></tt></a>()</td>
<td>Flag the array as X-ray amplitudes (F).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.set_observation_type_xray_intensity" title="cctbx.miller.array.set_observation_type_xray_intensity"><tt class="xref py py-obj docutils literal"><span class="pre">set_observation_type_xray_intensity</span></tt></a>()</td>
<td>Flag the array as X-ray intensities (I).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.set_sigmas" title="cctbx.miller.array.set_sigmas"><tt class="xref py py-obj docutils literal"><span class="pre">set_sigmas</span></tt></a>(sigmas)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">setup_binner</span></tt>([d_max,&nbsp;d_min,&nbsp;auto_binning,&nbsp;...])</td>
<td>Create internal resolution binner object; required for many other methods to work.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">setup_binner_counting_sorted</span></tt>([d_max,&nbsp;d_min,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">setup_binner_d_star_sq_step</span></tt>([auto_binning,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.shelxl_extinction_correction" title="cctbx.miller.array.shelxl_extinction_correction"><tt class="xref py py-obj docutils literal"><span class="pre">shelxl_extinction_correction</span></tt></a>(x,&nbsp;wavelength)</td>
<td>Extinction parameter x, where Fc is multiplied by:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.show_all_possible_systematic_absences" title="cctbx.miller.array.show_all_possible_systematic_absences"><tt class="xref py py-obj docutils literal"><span class="pre">show_all_possible_systematic_absences</span></tt></a>([out,&nbsp;...])</td>
<td>For each possible space group sharing the same basic intensity symmetry, show a list of possible systematically absent reflections and corresponding I/sigmaI.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.show_array" title="cctbx.miller.array.show_array"><tt class="xref py py-obj docutils literal"><span class="pre">show_array</span></tt></a>([f,&nbsp;prefix,&nbsp;deg])</td>
<td>Listing of Miller indices and data</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">show_completeness</span></tt>([reflections_per_bin,&nbsp;out])</td>
<td>Display the completeness in resolution bins.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.show_comprehensive_summary" title="cctbx.miller.array.show_comprehensive_summary"><tt class="xref py py-obj docutils literal"><span class="pre">show_comprehensive_summary</span></tt></a>([f,&nbsp;prefix])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.show_disagreeable_reflections" title="cctbx.miller.array.show_disagreeable_reflections"><tt class="xref py py-obj docutils literal"><span class="pre">show_disagreeable_reflections</span></tt></a>(f_calc_sq[,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.show_mean_data_over_sigma_along_a_b_c_star" title="cctbx.miller.array.show_mean_data_over_sigma_along_a_b_c_star"><tt class="xref py py-obj docutils literal"><span class="pre">show_mean_data_over_sigma_along_a_b_c_star</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.show_r_free_flags_info" title="cctbx.miller.array.show_r_free_flags_info"><tt class="xref py py-obj docutils literal"><span class="pre">show_r_free_flags_info</span></tt></a>([n_bins,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.show_summary" title="cctbx.miller.array.show_summary"><tt class="xref py py-obj docutils literal"><span class="pre">show_summary</span></tt></a>([f,&nbsp;prefix])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.sigma_at_first_index" title="cctbx.miller.array.sigma_at_first_index"><tt class="xref py py-obj docutils literal"><span class="pre">sigma_at_first_index</span></tt></a>(miller_index)</td>
<td>Returns the value of sigmas of the first index matching <cite>miller_index</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.sigma_filter" title="cctbx.miller.array.sigma_filter"><tt class="xref py py-obj docutils literal"><span class="pre">sigma_filter</span></tt></a>(cutoff_factor[,&nbsp;negate])</td>
<td>Return a copy of the array filtered to remove reflections whose value is less than cutoff_factor*sigma (or the reverse, if negate=True).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.sigmas" title="cctbx.miller.array.sigmas"><tt class="xref py py-obj docutils literal"><span class="pre">sigmas</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.sigmas_are_sensible" title="cctbx.miller.array.sigmas_are_sensible"><tt class="xref py py-obj docutils literal"><span class="pre">sigmas_are_sensible</span></tt></a>([critical_ratio,&nbsp;epsilon])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sin_theta_over_lambda_sq</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.size" title="cctbx.miller.array.size"><tt class="xref py py-obj docutils literal"><span class="pre">size</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">slice</span></tt>([axis,&nbsp;axis_index,&nbsp;slice_index,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sort</span></tt>([by_value,&nbsp;reverse])</td>
<td>Reorder reflections by resolution or Miller index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.sort_permutation" title="cctbx.miller.array.sort_permutation"><tt class="xref py py-obj docutils literal"><span class="pre">sort_permutation</span></tt></a>([by_value,&nbsp;reverse])</td>
<td>Generate the selection array (flex.size_t object) to reorder the array by resolution, Miller index, data values, or absolute data values.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">space_group</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">space_group_info</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">special_position_settings</span></tt>([...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.statistical_mean" title="cctbx.miller.array.statistical_mean"><tt class="xref py py-obj docutils literal"><span class="pre">statistical_mean</span></tt></a>([use_binning])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">structure_factors_from_map</span></tt>(map[,&nbsp;...])</td>
<td>Run FFT on a real-space map to calculate structure factors corresponding to the current set of Miller indices.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">structure_factors_from_scatterers</span></tt>(xray_structure)</td>
<td>Calculate structure factors for an <a class="reference internal" href="cctbx.xray.structure.html#module-cctbx.xray.structure" title="cctbx.xray.structure"><tt class="xref py py-class docutils literal"><span class="pre">cctbx.xray.structure</span></tt></a> object corresponding to the current set of Miller indices.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">subtract_continuous_allowed_origin_shifts</span></tt>(...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.sum" title="cctbx.miller.array.sum"><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt></a>([use_binning,&nbsp;use_multiplicities,&nbsp;squared])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.sum_sq" title="cctbx.miller.array.sum_sq"><tt class="xref py py-obj docutils literal"><span class="pre">sum_sq</span></tt></a>([use_binning,&nbsp;use_multiplicities])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.symmetry_agreement_factor" title="cctbx.miller.array.symmetry_agreement_factor"><tt class="xref py py-obj docutils literal"><span class="pre">symmetry_agreement_factor</span></tt></a>(op[,&nbsp;...])</td>
<td>The factor phi_{sym} quantifying whether complex structure factors are invariant under the given symmetry operator, as used in Superflip.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sys_absent_flags</span></tt>([integral_only])</td>
<td>Generate a boolean Miller array flagging those reflections which are systematically absent under the current symmetry.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.twin_data" title="cctbx.miller.array.twin_data"><tt class="xref py py-obj docutils literal"><span class="pre">twin_data</span></tt></a>(twin_law,&nbsp;alpha)</td>
<td>Apply a twin law to the data, returning an array of the same original type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">two_theta</span></tt>(wavelength[,&nbsp;deg])</td>
<td>Generate a double Miller array containing the scattering angle of each index.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unique_under_symmetry</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unique_under_symmetry_selection</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unit_cell</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">use_binner_of</span></tt>(other)</td>
<td>Use the exact binner of another set, which must have identical indices.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">use_binning</span></tt>(binning)</td>
<td>Use the resolution binning of the specified binner object (does not need to be from an identically sized set).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">use_binning_of</span></tt>(other)</td>
<td>Use the resolution binning of the specified set (does not need to be an identical set of indices).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.value_at_index" title="cctbx.miller.array.value_at_index"><tt class="xref py py-obj docutils literal"><span class="pre">value_at_index</span></tt></a>(hkl)</td>
<td>Extract the value of the array for the specified reflection h,k,l</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.array.wilson_plot" title="cctbx.miller.array.wilson_plot"><tt class="xref py py-obj docutils literal"><span class="pre">wilson_plot</span></tt></a>([use_binning])</td>
<td>&lt;F^2&gt;</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.array.wilson_ratio" title="cctbx.miller.array.wilson_ratio"><tt class="xref py py-obj docutils literal"><span class="pre">wilson_ratio</span></tt></a>([use_binning])</td>
<td>(&lt;F&gt;)^2/&lt;F^2&gt; (0.785 for untwinned, 0.885 for twinned data)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cctbx.miller.array.adopt_set">
<tt class="descname">adopt_set</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.adopt_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.amplitude_normalisations">
<tt class="descname">amplitude_normalisations</tt><big>(</big><em>asu_contents</em>, <em>wilson_plot=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.amplitude_normalisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Overriden version of set.amplitude_normalisation which computes
the Wilson parameters from the array data if wilson_plot is None.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.amplitude_quasi_normalisations">
<tt class="descname">amplitude_quasi_normalisations</tt><big>(</big><em>d_star_power=1</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.amplitude_quasi_normalisations" title="Permalink to this definition">¶</a></dt>
<dd><p>A miller.array whose data N(h) are the normalisations to convert
between locally normalised E&#8217;s and F&#8217;s:
E(h) = F(h) / N(h)</p>
<p>self features the F&#8217;s, which are then binned with the current binner
and N(h) is the average of F&#8217;s in the bin h belongs to.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.amplitudes">
<tt class="descname">amplitudes</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>For a complex array, return array of absolute values.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.analyze_intensity_statistics">
<tt class="descname">analyze_intensity_statistics</tt><big>(</big><em>d_min=2.5</em>, <em>completeness_as_non_anomalous=None</em>, <em>log=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.analyze_intensity_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect translational pseudosymmetry and twinning, using methods in
Xtriage.  Returns a mmtbx.scaling.twin_analyses.twin_law_interpretation
object.  (Requires mmtbx to be configured to be functional.)</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.anomalous_completeness">
<tt class="descname">anomalous_completeness</tt><big>(</big><em>use_binning=False</em>, <em>d_min_tolerance=1e-06</em>, <em>d_max=None</em>, <em>d_min=None</em>, <em>relative_to_complete_set=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.anomalous_completeness" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the percent of acenric reflections with both h,k,l and -h,-k,-l
observed (only meaningful for amplitude and intensity arrays).  By default
this is calculated relative to the complete set.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.anomalous_differences">
<tt class="descname">anomalous_differences</tt><big>(</big><em>enforce_positive_sigmas=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.anomalous_differences" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array object with DANO (i.e. F(+) - F(-)) as data, and
optionally SIGDANO as sigmas.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.anomalous_signal">
<tt class="descname">anomalous_signal</tt><big>(</big><em>use_binning=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.anomalous_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the anomalous signal according to this formula:</p>
<div class="math">
<p><img src="../_images/math/60c3401b9f5c8dd541f0423e7b8e6adbfd21f690.png" alt="\sqrt{\dfrac{&lt;||F(+)|-|F(-)||^2&gt;}{\frac{1}{2} (&lt;|F(+)|&gt;^2 + &lt;|F(-)|&gt;^2)}}"/></p>
</div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>use_binning</strong> (<em>boolean</em>) &#8211; If &#8216;True&#8217; the anomalous signal will be calculated for     each bin of the data set individually</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the anomalous signal</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float or cctbx.miller.binned_data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_change_of_basis">
<tt class="descname">apply_change_of_basis</tt><big>(</big><em>change_of_basis</em>, <em>eliminate_invalid_indices=True</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.apply_change_of_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates a variety of reindexing operations, including handling for a
variety of corner cases.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>change_of_basis</strong> &#8211; Python str for change-of-basis operator</li>
<li><strong>eliminate_invalid_indices</strong> &#8211; remove reflections with non-integral
indices</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new Miller array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_debye_waller_factors">
<tt class="descname">apply_debye_waller_factors</tt><big>(</big><em>u_iso=None</em>, <em>b_iso=None</em>, <em>u_cart=None</em>, <em>b_cart=None</em>, <em>u_cif=None</em>, <em>u_star=None</em>, <em>apply_to_sigmas=True</em>, <em>exp_arg_limit=50</em>, <em>truncate_exp_arg=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.apply_debye_waller_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an isotropic or anisotropic displacement or B-factor, apply
resolution-dependent scale factors to the data (and optionally sigmas).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u_iso</strong> &#8211; Isotropic displacement (in Angstroms)</li>
<li><strong>b_iso</strong> &#8211; Isotropic B-factor (8*pi^2*u_iso^2)</li>
<li><strong>u_cart</strong> &#8211; Anisotropic displacement tensor</li>
<li><strong>b_cart</strong> &#8211; Anisotropic B-factor</li>
<li><strong>u_star</strong> &#8211; Anisotropic displacement tensor in fractional space</li>
<li><strong>u_cif</strong> &#8211; Anisotropic displacement tensor, dimensionless basis</li>
<li><strong>apply_to_sigmas</strong> &#8211; Also scale sigma values (if present)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cctbx.miller.array object with scaled data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_scaling">
<tt class="descname">apply_scaling</tt><big>(</big><em>target_max=None</em>, <em>factor=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.apply_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a scale factor to the data (and optionally sigmas).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>target_max</strong> &#8211; target maximum value for the scaled data - the scale
factor will be determined automatically</li>
<li><strong>factor</strong> &#8211; explicit scale factor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">custumozed copy with scaled data and sigmas</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.apply_shelxl_extinction_correction">
<tt class="descname">apply_shelxl_extinction_correction</tt><big>(</big><em>x</em>, <em>wavelength</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.apply_shelxl_extinction_correction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.arg">
<tt class="descname">arg</tt><big>(</big><em>deg=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_amplitude_array">
<tt class="descname">as_amplitude_array</tt><big>(</big><em>algorithm='xtal_3_7'</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_amplitude_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the array to simple amplitudes if not already in that format.
Only valid for complex (i.e. F,PHI), intensity, or amplitude arrays.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_anomalous_array">
<tt class="descname">as_anomalous_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_anomalous_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array with identical contents (keeping original
flex arrays) but with the anomalous flag set to true.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_cif_block">
<tt class="descname">as_cif_block</tt><big>(</big><em>array_type</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_cif_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_cif_simple">
<tt class="descname">as_cif_simple</tt><big>(</big><em>array_type</em>, <em>out=None</em>, <em>data_name='global'</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_cif_simple" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_double">
<tt class="descname">as_double</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_double" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the array with the data converted to a flex.double type.
Will fail for incompatible arrays.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_intensity_array">
<tt class="descname">as_intensity_array</tt><big>(</big><em>algorithm='simple'</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_intensity_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the array to intensities if not already in that format.  Only valid
for complex (F,PHI), amplitude, or intensity arrays.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_mtz_dataset">
<tt class="descname">as_mtz_dataset</tt><big>(</big><em>column_root_label</em>, <em>column_types=None</em>, <em>label_decorator=None</em>, <em>title=None</em>, <em>crystal_name='crystal'</em>, <em>project_name='project'</em>, <em>dataset_name='dataset'</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_mtz_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an iotbx.mtz.dataset object for the array, which can be extended
with additional arrays and eventually written to an MTZ file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_non_anomalous_array">
<tt class="descname">as_non_anomalous_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_non_anomalous_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array with identical contents (keeping original
flex arrays) but with the anomalous flag set to false.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_phases_phs">
<tt class="descname">as_phases_phs</tt><big>(</big><em>out</em>, <em>scale_amplitudes=True</em>, <em>phases=None</em>, <em>phases_deg=None</em>, <em>figures_of_merit=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_phases_phs" title="Permalink to this definition">¶</a></dt>
<dd><p>Write phases to .phs file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.as_xray_observations">
<tt class="descname">as_xray_observations</tt><big>(</big><em>scale_indices=None</em>, <em>twin_fractions=None</em>, <em>twin_components=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.as_xray_observations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.average_bijvoet_mates">
<tt class="descname">average_bijvoet_mates</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.average_bijvoet_mates" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an anomalous array, merge the anomalous pairs and return the
non-anomalous average.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.bijvoet_ratios">
<tt class="descname">bijvoet_ratios</tt><big>(</big><em>obs_type='intensity'</em>, <em>measurable_only=True</em>, <em>cutoff=3.0</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.bijvoet_ratios" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.cc_anom">
<tt class="descname">cc_anom</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.cc_anom" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for array.half_dataset_anomalous_correlation()</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.cc_one_half">
<tt class="descname">cc_one_half</tt><big>(</big><em>use_binning=False</em>, <em>n_trials=1</em>, <em>anomalous_flag=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.cc_one_half" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation between two randomly assigned pools of unmerged
data (&#8220;CC 1/2&#8221;).  If desired the mean over multiple trials can be taken.
See Karplus PA &amp; Diederichs K (2012) Science 336:1030-3 for motivation.
This method assumes that the reflections still have the original indices
and maps them to the ASU first; the underlying compute_cc_one_half
function skips this method.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.change_basis">
<tt class="descname">change_basis</tt><big>(</big><em>cb_op</em>, <em>deg=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.change_basis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.change_symmetry">
<tt class="descname">change_symmetry</tt><big>(</big><em>space_group_symbol=None</em>, <em>space_group_info=None</em>, <em>volume_warning_threshold=0.001</em>, <em>expand_to_p1_if_necessary=True</em>, <em>remove_systematic_absences=True</em>, <em>merge_non_unique=True</em>, <em>log=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.change_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates all operations required to convert the original data to a
different symmetry (e.g. as suggested by Xtriage).  This includes
reindexing and adjusting the unit cell parameters if necessary, and
expansion to P1 (for moving to lower symmetry) or merging equivalents.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>space_group_symbol</strong> &#8211; Python str for space group symbol (any format)</li>
<li><strong>space_group_info</strong> &#8211; Pre-defined sgtbx.space_group_info object</li>
<li><strong>volume_warning_threshold</strong> &#8211; Cutoff for relative change in unit cell
volume beyond which a warning is issued.</li>
<li><strong>expand_to_p1_if_necessary</strong> &#8211; When moving to lower symmetry, expand the
data to P1 first.</li>
<li><strong>remove_systematic_absences</strong> &#8211; eliminate reflections that are
systematically absent in the new symmetry.</li>
<li><strong>merge_non_unique</strong> &#8211; merge reflections that are no longer symmetry-
unique under the new symmetry.</li>
<li><strong>log</strong> &#8211; filehandle-like object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Miller array in the new symmetry</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.combine">
<tt class="descname">combine</tt><big>(</big><em>other</em>, <em>scale=True</em>, <em>scale_for_lones=1</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.combine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.complete_array">
<tt class="descname">complete_array</tt><big>(</big><em>d_min_tolerance=1e-06</em>, <em>d_min=None</em>, <em>d_max=None</em>, <em>new_data_value=-1</em>, <em>new_sigmas_value=-1</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.complete_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.complete_with">
<tt class="descname">complete_with</tt><big>(</big><em>other</em>, <em>scale=False</em>, <em>replace_phases=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.complete_with" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.complete_with_bin_average">
<tt class="descname">complete_with_bin_average</tt><big>(</big><em>reflections_per_bin=100</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.complete_with_bin_average" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.concatenate">
<tt class="descname">concatenate</tt><big>(</big><em>other</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.concatenate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.conjugate">
<tt class="descname">conjugate</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.convert_to_non_anomalous_if_ratio_pairs_lone_less_than">
<tt class="descname">convert_to_non_anomalous_if_ratio_pairs_lone_less_than</tt><big>(</big><em>threshold</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.convert_to_non_anomalous_if_ratio_pairs_lone_less_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert anomalous array into nonanomalous if the number of Bijvoet pairs is
too small compared to the number of lone Bijvoet mates.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new array object using references to internal objects.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.correlation">
<tt class="descname">correlation</tt><big>(</big><em>other</em>, <em>use_binning=False</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate correlation coefficient between two arrays (either globally or
binned).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; another array of real numbers</li>
<li><strong>use_binning</strong> &#8211; calculate CC in resolution bins (default = calculate
a single global value)</li>
<li><strong>assert_is_similar_symmetry</strong> &#8211; check that arrays have compatible
crystal symmetry</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Python float (if use_binning=False), or a binned_data object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.count_and_fraction_in_bins">
<tt class="descname">count_and_fraction_in_bins</tt><big>(</big><em>data_value_to_count</em>, <em>count_not_equal=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.count_and_fraction_in_bins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.crystal_symmetry_is_compatible_with_symmetry_from_file">
<tt class="descname">crystal_symmetry_is_compatible_with_symmetry_from_file</tt><big>(</big><em>unit_cell_relative_length_tolerance=0.02</em>, <em>unit_cell_absolute_angle_tolerance=3.0</em>, <em>working_point_group=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.crystal_symmetry_is_compatible_with_symmetry_from_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.customized_copy">
<tt class="descname">customized_copy</tt><big>(</big><em>miller_set=Keep</em>, <em>data=Keep</em>, <em>sigmas=Keep</em>, <em>crystal_symmetry=Keep</em>, <em>indices=Keep</em>, <em>anomalous_flag=Keep</em>, <em>unit_cell=Keep</em>, <em>space_group_info=Keep</em>, <em>observation_type=Keep</em>, <em>info=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.customized_copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.data">
<tt class="descname">data</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.data_at_first_index">
<tt class="descname">data_at_first_index</tt><big>(</big><em>miller_index</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.data_at_first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of data of the first index matching
<cite>miller_index</cite>. If the <cite>miller_index</cite> is not found in <cite>self</cite>,
then returns <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>miller_index</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><em>tuple</em></a>) &#8211; Miller index as a 3-tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">int, float, complex, None &#8211; data value or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.deep_copy">
<tt class="descname">deep_copy</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.deep_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone the array, making copies of all internal array objects.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.detwin_data">
<tt class="descname">detwin_data</tt><big>(</big><em>twin_law</em>, <em>alpha</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.detwin_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Detwin data using a known twin fraction, returning an array with the same
original data type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Params twin_law:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">a valid twin law expressed as h,k,l operations</td>
</tr>
<tr class="field-even field"><th class="field-name">Params alpha:</th><td class="field-body">predicted twin fraction (0 to 0.5)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new array with detwinned data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.direct_summation_at_point">
<tt class="descname">direct_summation_at_point</tt><big>(</big><em>site_frac</em>, <em>sigma=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.direct_summation_at_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the exact map value at the specified fractional coordinate
using direct Fourier summation.  Relatively slow but avoids interpolation
errors.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.disagreeable_reflections">
<tt class="descname">disagreeable_reflections</tt><big>(</big><em>f_calc_sq</em>, <em>n_reflections=20</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.disagreeable_reflections" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.discard_sigmas">
<tt class="descname">discard_sigmas</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.discard_sigmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the array without sigmas.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.double_step_filtration">
<tt class="descname">double_step_filtration</tt><big>(</big><em>complete_set=None</em>, <em>vol_cutoff_plus_percent=5.0</em>, <em>vol_cutoff_minus_percent=5.0</em>, <em>resolution_factor=0.25</em>, <em>scale_to=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.double_step_filtration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.eliminate_sys_absent">
<tt class="descname">eliminate_sys_absent</tt><big>(</big><em>integral_only=False</em>, <em>log=None</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.eliminate_sys_absent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all reflections which should be systematically absent in the current
space group.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.ellipsoidal_resolutions_and_indices_by_sigma">
<tt class="descname">ellipsoidal_resolutions_and_indices_by_sigma</tt><big>(</big><em>sigma_cutoff=3</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.ellipsoidal_resolutions_and_indices_by_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.ellipsoidal_truncation_by_sigma">
<tt class="descname">ellipsoidal_truncation_by_sigma</tt><big>(</big><em>sigma_cutoff=3</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.ellipsoidal_truncation_by_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.enforce_positive_amplitudes">
<tt class="descname">enforce_positive_amplitudes</tt><big>(</big><em>i_sig_level=-4.0</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.enforce_positive_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes in an intensity array (including negatives) and spits out amplitudes.
The basic assumption is that
P(Itrue) propto exp(-(Itrue-Iobs)**2/(2*s))
where Itrue&gt;=0 (positivity constraint on error free amplitudes).
For amplitudes, this results in
P(Ftrue) propto 2 Ftrue exp( -(Ftrue**2-Iobs)**2/(2s) )
A Gaussian approximation is fitted to the Mode of this distribution.
An analytical solution exists and is implemented below.
This method does not require any Wilson statistics assumptions.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.enforce_positive_sigmas">
<tt class="descname">enforce_positive_sigmas</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.enforce_positive_sigmas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.expand_to_p1">
<tt class="descname">expand_to_p1</tt><big>(</big><em>phase_deg=None</em>, <em>return_iselection=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.expand_to_p1" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the equivalent P1 dataset.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.export_as_cns_hkl">
<tt class="descname">export_as_cns_hkl</tt><big>(</big><em>file_object</em>, <em>file_name=None</em>, <em>info=</em>, <span class="optional">[</span><span class="optional">]</span><em>array_names=None</em>, <em>r_free_flags=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.export_as_cns_hkl" title="Permalink to this definition">¶</a></dt>
<dd><p>Write reflections to a CNS-format file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.export_as_scalepack_unmerged">
<tt class="descname">export_as_scalepack_unmerged</tt><big>(</big><em>file_object=None</em>, <em>file_name=None</em>, <em>batch_numbers=None</em>, <em>spindle_flags=None</em>, <em>scale_intensities_for_scalepack_merge=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.export_as_scalepack_unmerged" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in unmerged scalepack format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>file_object</strong> &#8211; filehandle-like object</li>
<li><strong>file_name</strong> &#8211; output file to write</li>
<li><strong>batch_numbers</strong> &#8211; integer array indicating the batch (image) numbers
corresponding to the indices (optional)</li>
<li><strong>spindle_flags</strong> &#8211; integer array indicating the position of the
reflections on the detector (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.export_as_shelx_hklf">
<tt class="descname">export_as_shelx_hklf</tt><big>(</big><em>file_object=None</em>, <em>normalise_if_format_overflow=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.export_as_shelx_hklf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write reflections to a SHELX-format .hkl file.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_as_f_sq">
<tt class="descname">f_as_f_sq</tt><big>(</big><em>algorithm='simple'</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.f_as_f_sq" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert amplitudes (and associated sigmas, if present) to intensities.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_obs_f_calc_fan_outlier_selection">
<tt class="descname">f_obs_f_calc_fan_outlier_selection</tt><big>(</big><em>f_calc</em>, <em>offset_low=0.05</em>, <em>offset_high=0.1</em>, <em>also_return_x_and_y=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.f_obs_f_calc_fan_outlier_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Preconditions (not checked explicitly):
self is amplitude array,
f_calc is complex array or amplitude array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_obs_minus_f_calc">
<tt class="descname">f_obs_minus_f_calc</tt><big>(</big><em>f_obs_factor</em>, <em>f_calc</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.f_obs_minus_f_calc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.f_sq_as_f">
<tt class="descname">f_sq_as_f</tt><big>(</big><em>algorithm='xtal_3_7'</em>, <em>tolerance=1e-06</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.f_sq_as_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an intensity/F^2 array (or undefined observation type), return the
equivalent amplitudes.  Note that negative intensities will be discarded;
for French-Wilson treatment, call the separate array.french_wilson()
method.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.fft_map">
<tt class="descname">fft_map</tt><big>(</big><em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>grid_step=None</em>, <em>crystal_gridding=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em>, <em>f_000=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.fft_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the FFT for the array, assuming the data are complex doubles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>resolution_factor</strong> &#8211; when multiplied times the resolution limit, gives
the approximate grid spacing of the map.</li>
<li><strong>d_min</strong> &#8211; High-resolution cutoff</li>
<li><strong>crystal_gridding</strong> &#8211; optional gridding to use (overrides automatic
gridding)</li>
<li><strong>symmetry_flags</strong> &#8211; specifies how the grid should be constructed to
handle symmetry</li>
<li><strong>f_000</strong> &#8211; Optional F(0,0,0) value (scalar added to entire map)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an fft_map object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.french_wilson">
<tt class="descname">french_wilson</tt><big>(</big><em>**kwds</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.french_wilson" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform French-Wilson treatment of X-ray intensities to estimate the &#8220;true&#8221;
intensities, replacing very weak and/or negative values, and takes the
square root to obtain amplitudes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array of all-positive X-ray amplitudes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="cctbx.miller.array.from_cif">
<em class="property">classmethod </em><tt class="descname">from_cif</tt><big>(</big><em>file_object=None</em>, <em>file_path=None</em>, <em>data_block_name=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.from_cif" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method for building an array from a CIF file (or filehandle).
Depends on iotbx.cif.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.generate_bijvoet_mates">
<tt class="descname">generate_bijvoet_mates</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.generate_bijvoet_mates" title="Permalink to this definition">¶</a></dt>
<dd><p>If the array is not already anomalous, expand to generate anomalous pairs
(without changing data).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.half_dataset_anomalous_correlation">
<tt class="descname">half_dataset_anomalous_correlation</tt><big>(</big><em>use_binning=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.half_dataset_anomalous_correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation of the anomalous differences of two randomly
assigned half-datasets (starting from unmerged data).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.has_twinning">
<tt class="descname">has_twinning</tt><big>(</big><em>d_min=2.5</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.has_twinning" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method for identifying twinned data.  Note that this is
hugely inefficient if any other Xtriage analyses are planned, since it
discards the other results.  Requires mmtbx.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.hemisphere_acentrics">
<tt class="descname">hemisphere_acentrics</tt><big>(</big><em>plus_or_minus</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.hemisphere_acentrics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.hemispheres_acentrics">
<tt class="descname">hemispheres_acentrics</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.hemispheres_acentrics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.hoppe_gassmann_modification">
<tt class="descname">hoppe_gassmann_modification</tt><big>(</big><em>mean_scale</em>, <em>n_iterations</em>, <em>resolution_factor=0.25</em>, <em>d_min=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.hoppe_gassmann_modification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.i_over_sig_i">
<tt class="descname">i_over_sig_i</tt><big>(</big><em>use_binning=False</em>, <em>return_fail=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.i_over_sig_i" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;I/sigma_I&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.info">
<tt class="descname">info</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the associated info object, or None if undefined.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.intensities">
<tt class="descname">intensities</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.intensities" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_bool_array">
<tt class="descname">is_bool_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_bool_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_complex_array">
<tt class="descname">is_complex_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_complex_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_hendrickson_lattman_array">
<tt class="descname">is_hendrickson_lattman_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_hendrickson_lattman_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_integer_array">
<tt class="descname">is_integer_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_integer_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_real_array">
<tt class="descname">is_real_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_real_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_string_array">
<tt class="descname">is_string_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_string_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_unmerged_intensity_array">
<tt class="descname">is_unmerged_intensity_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_unmerged_intensity_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the array contains unmerged experimental observations
or not.  In some files only the centric reflections will appear to be
unmerged, so we specifically check the acentrics (if present).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_amplitude_array">
<tt class="descname">is_xray_amplitude_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_xray_amplitude_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_data_array">
<tt class="descname">is_xray_data_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_xray_data_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_intensity_array">
<tt class="descname">is_xray_intensity_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_xray_intensity_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.is_xray_reconstructed_amplitude_array">
<tt class="descname">is_xray_reconstructed_amplitude_array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.is_xray_reconstructed_amplitude_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.local_standard_deviation_map">
<tt class="descname">local_standard_deviation_map</tt><big>(</big><em>radius</em>, <em>mean_solvent_density=0</em>, <em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>grid_step=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em>, <em>f_000=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.local_standard_deviation_map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.map_correlation">
<tt class="descname">map_correlation</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.map_correlation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.map_to_asu">
<tt class="descname">map_to_asu</tt><big>(</big><em>deg=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.map_to_asu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert all indices to lie within the canonical asymmetric unit for the
current space group (while preserving anomalous flag).  Required for many
downstream steps.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.matching_set">
<tt class="descname">matching_set</tt><big>(</big><em>other</em>, <em>data_substitute</em>, <em>sigmas_substitute=None</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.matching_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean">
<tt class="descname">mean</tt><big>(</big><em>use_binning=False</em>, <em>use_multiplicities=False</em>, <em>squared=False</em>, <em>rms=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_of_intensity_divided_by_epsilon">
<tt class="descname">mean_of_intensity_divided_by_epsilon</tt><big>(</big><em>use_binning=False</em>, <em>return_fail=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.mean_of_intensity_divided_by_epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;I/epsilon&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_of_squared_sigma_divided_by_epsilon">
<tt class="descname">mean_of_squared_sigma_divided_by_epsilon</tt><big>(</big><em>use_binning=False</em>, <em>return_fail=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.mean_of_squared_sigma_divided_by_epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;sigma^2/epsilon&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_phase_error">
<tt class="descname">mean_phase_error</tt><big>(</big><em>phase_source</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.mean_phase_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_sq">
<tt class="descname">mean_sq</tt><big>(</big><em>use_binning=False</em>, <em>use_multiplicities=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.mean_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.mean_weighted_phase_error">
<tt class="descname">mean_weighted_phase_error</tt><big>(</big><em>phase_source</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.mean_weighted_phase_error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.measurability">
<tt class="descname">measurability</tt><big>(</big><em>use_binning=False</em>, <em>cutoff=3.0</em>, <em>return_fail=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.measurability" title="Permalink to this definition">¶</a></dt>
<dd><p>Fraction of reflections for which
(<img class="math" src="../_images/math/c25bc09bdeb1610782c5fc4af628b5c71f540afb.png" alt="\dfrac{|\Delta I|}{\sigma_{dI}}"/> &gt; cutoff and
<img class="math" src="../_images/math/115b15a8a3f4ca22d94d6b3c962a0b5073209e6d.png" alt="min(\dfrac{I_{+}}{\sigma_{+}},\dfrac{I_{-}}{\sigma_{-}})"/> &gt; cutoff</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.merge_equivalents">
<tt class="descname">merge_equivalents</tt><big>(</big><em>algorithm='gaussian'</em>, <em>incompatible_flags_replacement=None</em>, <em>use_internal_variance=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.merge_equivalents" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a non-unique array, merge the symmetry-related reflections (keeping
anomalous flag).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a merge_equivalents object, from which the merged array may     be extracted by calling the array() method.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.min_f_over_sigma">
<tt class="descname">min_f_over_sigma</tt><big>(</big><em>return_none_if_zero_sigmas=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.min_f_over_sigma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.multiscale">
<tt class="descname">multiscale</tt><big>(</big><em>other</em>, <em>reflections_per_bin=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.multiscale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.norm">
<tt class="descname">norm</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.norm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.normalised_amplitudes">
<tt class="descname">normalised_amplitudes</tt><big>(</big><em>asu_contents</em>, <em>wilson_plot=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.normalised_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.normalize">
<tt class="descname">normalize</tt><big>(</big><em>reflections_per_bin=150</em>, <em>eps_fac=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute E-values: E = (F/eps**0.5) / rms of (F/eps**0.5)
This is &#8216;Karle&#8217; approach, that is not using overall B from Wilson plot.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.observation_type">
<tt class="descname">observation_type</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.observation_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (experimental) data type, if defined.  See the module
cctbx.xray.observation_types for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an object from cctbx.xray.observation_types</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.patterson_map">
<tt class="descname">patterson_map</tt><big>(</big><em>resolution_factor=0.3333333333333333</em>, <em>d_min=None</em>, <em>symmetry_flags=None</em>, <em>mandatory_factors=None</em>, <em>max_prime=5</em>, <em>assert_shannon_sampling=True</em>, <em>f_000=None</em>, <em>sharpening=False</em>, <em>origin_peak_removal=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.patterson_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate an unphased Patterson map.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.patterson_symmetry">
<tt class="descname">patterson_symmetry</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.patterson_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.permute_d_range">
<tt class="descname">permute_d_range</tt><big>(</big><em>d_max</em>, <em>d_min</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.permute_d_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly shuffle reflections within a given resolution range.  Used for
control refinements to validate the information content of a dataset.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phase_entropy">
<tt class="descname">phase_entropy</tt><big>(</big><em>exponentiate=False</em>, <em>return_binned_data=False</em>, <em>return_mean=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.phase_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Get phase entropy as measured in terms of an base-360 entropy
(base-2 for centrics).</p>
<p>An entropy of 0, indicates that the phase uncertainity is as low as possible
An entropy of 1 however, indicates that the uncertainty is maximal:
all phases are equally likely!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>return_binned_data</strong> (<em>boolean</em>) &#8211; if &#8216;True&#8217; you receive a binned object rather     then a raw array</li>
<li><strong>exponentiate</strong> (<em>boolean</em>) &#8211; whether or not to exponentiate the entropy. This will     return a phase uncertainty in degrees (or the &#8216;alphabet size&#8217;)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phase_integrals">
<tt class="descname">phase_integrals</tt><big>(</big><em>n_steps=None</em>, <em>integrator=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.phase_integrals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phase_transfer">
<tt class="descname">phase_transfer</tt><big>(</big><em>phase_source</em>, <em>epsilon=1e-10</em>, <em>deg=False</em>, <em>phase_integrator_n_steps=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.phase_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines phases of phase_source with self&#8217;s data if real (keeping
the sign of self&#8217;s data) or with self&#8217;s amplitudes if complex.</p>
<p>Centric reflections are forced to be compatible with the phase restrictions.</p>
<p>phase_source can be a miller.array or a plain flex array.</p>
<p>epsilon is only used when phase_source is a complex array. If both the
real and the imaginary part of phase_source[i] &lt; epsilon the phase is
assumed to be 0.</p>
<p>deg is only used if phase_source is an array of doubles.
deg=True indicates that the phases are given in degrees,
deg=False indicates phases are given in radians.</p>
<p>phase_integrator_n_steps is only used if phase_source is an
array of Hendrickson-Lattman coefficients. The centroid
phases are determined on the fly using the given step size.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phased_translation_function_coeff">
<tt class="descname">phased_translation_function_coeff</tt><big>(</big><em>phase_source</em>, <em>f_calc</em>, <em>fom=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.phased_translation_function_coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.phases">
<tt class="descname">phases</tt><big>(</big><em>deg=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.phases" title="Permalink to this definition">¶</a></dt>
<dd><p>For a complex array, return the array of its phases (in radians by default).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.quasi_normalize_structure_factors">
<tt class="descname">quasi_normalize_structure_factors</tt><big>(</big><em>d_star_power=1</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.quasi_normalize_structure_factors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.quasi_normalized_as_normalized">
<tt class="descname">quasi_normalized_as_normalized</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.quasi_normalized_as_normalized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.r1_factor">
<tt class="descname">r1_factor</tt><big>(</big><em>other</em>, <em>scale_factor=None</em>, <em>assume_index_matching=False</em>, <em>use_binning=False</em>, <em>emulate_sftools=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.r1_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the R1 factor according to this formula</p>
<div class="math">
<p><img src="../_images/math/761dfc3b1700c0c185608194f0fda812a58fcd5b.png" alt="R1 = \dfrac{\sum{||F| - k|F'||}}{\sum{|F|}}"/></p>
</div><p>where F is self.data() and F&#8217; is other.data() and
k is the factor to put F&#8217; on the same scale as F</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; array object with the same observation type</li>
<li><strong>scale_factor</strong> &#8211; optional scale factor to be applied to &#8216;other&#8217;; if
Auto, will be determined automatically</li>
<li><strong>assume_index_matching</strong> &#8211; skips calling self.common_sets(other)</li>
<li><strong>use_binning</strong> &#8211; divide by resolution shells</li>
<li><strong>emulate_sftools</strong> &#8211; copies behavior of SFTOOLS in CCP4: instead of
the denominator being sum(self.data()), it will be 0.5*sum(self.data()+
other.data())</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Python float (if use_binning=False), or a binned_data object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.r_anom">
<tt class="descname">r_anom</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.r_anom" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate R_anom, which measures the agreement between Friedel mates.
Unlike CC_anom and various other R-factors (such as R_pim, which it is
usually compared to), this requires merged data.</p>
<div class="math">
<p><img src="../_images/math/4977c1e1a5224b457320f01456f4961fc8240418.png" alt="R_{anom} = \dfrac{\sum_{hkl}{|I_{hkl} - I_{-h,-k,-l}|}}{\sum_{hkl}{\left \langle I_{hkl} \right \rangle}}"/></p>
</div></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.r_free_flags_accumulation">
<tt class="descname">r_free_flags_accumulation</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.r_free_flags_accumulation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.randomize_amplitude_and_phase">
<tt class="descname">randomize_amplitude_and_phase</tt><big>(</big><em>amplitude_error</em>, <em>phase_error_deg</em>, <em>selection=None</em>, <em>random_seed=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.randomize_amplitude_and_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Add random error to reflections.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.randomize_phases">
<tt class="descname">randomize_phases</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.randomize_phases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.remove_cone">
<tt class="descname">remove_cone</tt><big>(</big><em>fraction_percent</em>, <em>vertex=(0</em>, <em>0</em>, <em>0)</em>, <em>axis_point_1=(0</em>, <em>0</em>, <em>0)</em>, <em>axis_point_2=(0</em>, <em>0</em>, <em>1)</em>, <em>negate=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.remove_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove reflections corresponding to a cone shape in reciprocal space with
the apex at the origin.  Used to simulate incomplete data due to poor
alignment of the crystal with the goniometer axis.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.remove_patterson_origin_peak">
<tt class="descname">remove_patterson_origin_peak</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.remove_patterson_origin_peak" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.rms">
<tt class="descname">rms</tt><big>(</big><em>use_binning=False</em>, <em>use_multiplicities=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.rms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.rms_filter">
<tt class="descname">rms_filter</tt><big>(</big><em>cutoff_factor</em>, <em>use_binning=False</em>, <em>use_multiplicities=False</em>, <em>negate=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.rms_filter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.scale">
<tt class="descname">scale</tt><big>(</big><em>other</em>, <em>resolution_dependent=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.scale_factor">
<tt class="descname">scale_factor</tt><big>(</big><em>f_calc</em>, <em>weights=None</em>, <em>cutoff_factor=None</em>, <em>use_binning=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.scale_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytical expression for the least squares scale factor.</p>
<p>K = sum(w * yo * yc) / sum(w * yc^2)</p>
<p>If the optional cutoff_factor argument is provided, only the reflections
whose magnitudes are greater than cutoff_factor * max(yo) will be included
in the calculation.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.second_moment">
<tt class="descname">second_moment</tt><big>(</big><em>use_binning=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.second_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;data^2&gt;/(&lt;data&gt;)^2</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.second_moment_of_intensities">
<tt class="descname">second_moment_of_intensities</tt><big>(</big><em>use_binning=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.second_moment_of_intensities" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;I^2&gt;/(&lt;I&gt;)^2 (2.0 for untwinned, 1.5 for twinned data)</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.second_moments_centric_acentric">
<tt class="descname">second_moments_centric_acentric</tt><big>(</big><em>reflections_per_bin=150</em>, <em>eps_fac=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.second_moments_centric_acentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute &lt;E**4&gt;/&lt;E**2&gt;**2 for centric and acentric reflections.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.select">
<tt class="descname">select</tt><big>(</big><em>selection</em>, <em>negate=False</em>, <em>anomalous_flag=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a sub-array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>selection</strong> &#8211; flex.bool or flex.size_t selection</li>
<li><strong>negate</strong> &#8211; select the inverse of the selection array</li>
<li><strong>anomalous_flag</strong> &#8211; anomalous flag for the new set</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a new array with a subset of indices and data/sigmas</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.select_indices">
<tt class="descname">select_indices</tt><big>(</big><em>indices</em>, <em>map_indices_to_asu=False</em>, <em>negate=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.select_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.select_sys_absent">
<tt class="descname">select_sys_absent</tt><big>(</big><em>integral_only=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.select_sys_absent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set">
<tt class="descname">set</tt><big>(</big><em>crystal_symmetry=Keep</em>, <em>indices=Keep</em>, <em>anomalous_flag=Keep</em>, <em>unit_cell=Keep</em>, <em>space_group_info=Keep</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the basic cctbx.miller.set object for the array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_info">
<tt class="descname">set_info</tt><big>(</big><em>info</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.set_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_observation_type">
<tt class="descname">set_observation_type</tt><big>(</big><em>observation_type</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.set_observation_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_observation_type_xray_amplitude">
<tt class="descname">set_observation_type_xray_amplitude</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.set_observation_type_xray_amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag the array as X-ray amplitudes (F).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_observation_type_xray_intensity">
<tt class="descname">set_observation_type_xray_intensity</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.set_observation_type_xray_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag the array as X-ray intensities (I).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.set_sigmas">
<tt class="descname">set_sigmas</tt><big>(</big><em>sigmas</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.set_sigmas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.shelxl_extinction_correction">
<tt class="descname">shelxl_extinction_correction</tt><big>(</big><em>x</em>, <em>wavelength</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.shelxl_extinction_correction" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Extinction parameter x, where Fc is multiplied by:</dt>
<dd>k[1 + 0.001 x Fc^2 wavelength^3 / sin(2theta)]^(-1/4)</dd>
</dl>
<p>See SHELX-97 manual, page 7-7 for more information.</p>
<dl class="docutils">
<dt>Note: The scale factor, k, is not applied nor calculated by</dt>
<dd>this function. The scale factor should be calculated
and applied <strong>*AFTER*</strong> the application of the extinction
corrections.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_all_possible_systematic_absences">
<tt class="descname">show_all_possible_systematic_absences</tt><big>(</big><em>out=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x7fbc46f65150&gt;</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.show_all_possible_systematic_absences" title="Permalink to this definition">¶</a></dt>
<dd><p>For each possible space group sharing the same basic intensity symmetry,
show a list of possible systematically absent reflections and corresponding
I/sigmaI.  Note that if the data have already been processed in a specific
space group rather than the basic point group, for example P212121 instead
of P222, all systematically absent reflections are likely to have been
removed already.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a systematic_absences_info object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_array">
<tt class="descname">show_array</tt><big>(</big><em>f=None</em>, <em>prefix=''</em>, <em>deg=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.show_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Listing of Miller indices and data</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_comprehensive_summary">
<tt class="descname">show_comprehensive_summary</tt><big>(</big><em>f=None</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.show_comprehensive_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_disagreeable_reflections">
<tt class="descname">show_disagreeable_reflections</tt><big>(</big><em>f_calc_sq</em>, <em>n_reflections=20</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.show_disagreeable_reflections" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_mean_data_over_sigma_along_a_b_c_star">
<tt class="descname">show_mean_data_over_sigma_along_a_b_c_star</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.show_mean_data_over_sigma_along_a_b_c_star" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_r_free_flags_info">
<tt class="descname">show_r_free_flags_info</tt><big>(</big><em>n_bins=10</em>, <em>binner_range='used'</em>, <em>out=None</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.show_r_free_flags_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.show_summary">
<tt class="descname">show_summary</tt><big>(</big><em>f=None</em>, <em>prefix=''</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.show_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigma_at_first_index">
<tt class="descname">sigma_at_first_index</tt><big>(</big><em>miller_index</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.sigma_at_first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of sigmas of the first index matching
<cite>miller_index</cite>. If the <cite>miller_index</cite> is not found in <cite>self</cite>,
then returns <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>miller_index</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><em>tuple</em></a>) &#8211; Miller index as a 3-tuple</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">int, float, complex, None &#8211; sigmas value or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigma_filter">
<tt class="descname">sigma_filter</tt><big>(</big><em>cutoff_factor</em>, <em>negate=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.sigma_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array filtered to remove reflections whose value is
less than cutoff_factor*sigma (or the reverse, if negate=True).</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigmas">
<tt class="descname">sigmas</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.sigmas" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sigmas_are_sensible">
<tt class="descname">sigmas_are_sensible</tt><big>(</big><em>critical_ratio=0.75</em>, <em>epsilon=1e-06</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.sigmas_are_sensible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.size">
<tt class="descname">size</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.array.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sort_permutation">
<tt class="descname">sort_permutation</tt><big>(</big><em>by_value='resolution'</em>, <em>reverse=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.sort_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the selection array (flex.size_t object) to reorder the array
by resolution, Miller index, data values, or absolute data values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>by_value</strong> &#8211; sort type, must be &#8220;resolution&#8221;, &#8220;packed_indices&#8221;, &#8220;data&#8221;,
or &#8220;abs&#8221;</li>
<li><strong>reverse</strong> &#8211; invert order</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">flex.size_t object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.statistical_mean">
<tt class="descname">statistical_mean</tt><big>(</big><em>use_binning=0</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.statistical_mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sum">
<tt class="descname">sum</tt><big>(</big><em>use_binning=False</em>, <em>use_multiplicities=False</em>, <em>squared=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.sum_sq">
<tt class="descname">sum_sq</tt><big>(</big><em>use_binning=False</em>, <em>use_multiplicities=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.sum_sq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.symmetry_agreement_factor">
<tt class="descname">symmetry_agreement_factor</tt><big>(</big><em>op</em>, <em>assert_is_similar_symmetry=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.symmetry_agreement_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>The factor phi_{sym} quantifying whether complex structure factors
are invariant under the given symmetry operator, as used in Superflip.
Ref: J. Appl. Cryst. (2008). 41, 975-984</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.twin_data">
<tt class="descname">twin_data</tt><big>(</big><em>twin_law</em>, <em>alpha</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.twin_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a twin law to the data, returning an array of the same original type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Params twin_law:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">a valid twin law expressed as h,k,l operations</td>
</tr>
<tr class="field-even field"><th class="field-name">Params alpha:</th><td class="field-body">predicted twin fraction (0 to 0.5)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a new array with synthetically twinned data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.value_at_index">
<tt class="descname">value_at_index</tt><big>(</big><em>hkl</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.value_at_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the value of the array for the specified reflection h,k,l</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.wilson_plot">
<tt class="descname">wilson_plot</tt><big>(</big><em>use_binning=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.wilson_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>&lt;F^2&gt;</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.array.wilson_ratio">
<tt class="descname">wilson_ratio</tt><big>(</big><em>use_binning=False</em><big>)</big><a class="headerlink" href="#cctbx.miller.array.wilson_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>(&lt;F&gt;)^2/&lt;F^2&gt; (0.785 for untwinned, 0.885 for twinned data)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="utility-classes">
<h2>Utility classes<a class="headerlink" href="#utility-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cctbx.miller.merge_equivalents">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">merge_equivalents</tt><big>(</big><em>miller_array</em>, <em>algorithm='gaussian'</em>, <em>incompatible_flags_replacement=None</em>, <em>use_internal_variance=True</em><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for merging redundant observations to obtain a symmetry-unique
array.  This also calculates some useful statistics resulting from the
merging operation.  Normally this would not be instantiated directly, but
instead obtained by calling array.merge_equivalents(...).</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.merge_equivalents.array" title="cctbx.miller.merge_equivalents.array"><tt class="xref py py-obj docutils literal"><span class="pre">array</span></tt></a>()</td>
<td>Return the merged Miller array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">inconsistent_equivalents</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">r_int</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.merge_equivalents.r_linear" title="cctbx.miller.merge_equivalents.r_linear"><tt class="xref py py-obj docutils literal"><span class="pre">r_linear</span></tt></a>()</td>
<td>R-linear = sum(abs(data - mean(data))) / sum(abs(data))</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.merge_equivalents.r_meas" title="cctbx.miller.merge_equivalents.r_meas"><tt class="xref py py-obj docutils literal"><span class="pre">r_meas</span></tt></a>()</td>
<td>Alternate metric of dataset internal consistency.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.merge_equivalents.r_merge" title="cctbx.miller.merge_equivalents.r_merge"><tt class="xref py py-obj docutils literal"><span class="pre">r_merge</span></tt></a>()</td>
<td>Standard (but flawed) metric of dataset internal consistency.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.merge_equivalents.r_pim" title="cctbx.miller.merge_equivalents.r_pim"><tt class="xref py py-obj docutils literal"><span class="pre">r_pim</span></tt></a>()</td>
<td>Alternate metric of dataset internal consistency or quality.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">r_sigma</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cctbx.miller.merge_equivalents.r_square" title="cctbx.miller.merge_equivalents.r_square"><tt class="xref py py-obj docutils literal"><span class="pre">r_square</span></tt></a>()</td>
<td>R-square = sum((data - mean(data))**2) / sum(data**2)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cctbx.miller.merge_equivalents.redundancies" title="cctbx.miller.merge_equivalents.redundancies"><tt class="xref py py-obj docutils literal"><span class="pre">redundancies</span></tt></a>()</td>
<td>Return an array representing the redundancy or multiplicity of each reflection in the merged array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">show_summary</span></tt>([n_bins,&nbsp;out,&nbsp;prefix])</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cctbx.miller.merge_equivalents.array">
<tt class="descname">array</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the merged Miller array.</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_linear">
<tt class="descname">r_linear</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>R-linear = sum(abs(data - mean(data))) / sum(abs(data))</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_meas">
<tt class="descname">r_meas</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_meas" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternate metric of dataset internal consistency.  Explained in detail in
Diederichs K &amp; Karplus PA (1997) Nature Structural Biology 4:269-275.</p>
<div class="math">
<p><img src="../_images/math/4a2ca03aa1c25c31674da08ab869a3bf652eb7b7.png" alt="R_{meas} = \dfrac{\sum_{hkl}{ {\left \{ N(hkl) / [N(hkl) - 1] \right \} }^{1/2} \times \sum_{i}{|I_{i}(hkl) - \left \langle I_{i}(hkl) \right \rangle|}}}{\sum_{hkl}{\sum_{i}{I_{i}(hkl)}}}"/></p>
</div></dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_merge">
<tt class="descname">r_merge</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard (but flawed) metric of dataset internal consistency.</p>
<div class="math">
<p><img src="../_images/math/fd6e5d542edafc982cc5f012eca4eea42e278242.png" alt="R_{merge} = \dfrac{\sum_{hkl}{\sum_{i}{|I_{i}(hkl) - \left \langle I_{i}(hkl) \right \rangle|}}}{\sum_{hkl}{\sum_{i}{I_{i}(hkl)}}}"/></p>
</div></dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_pim">
<tt class="descname">r_pim</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_pim" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternate metric of dataset internal consistency or quality.  Explained in
detail in Weiss MS (2001) J Appl Cryst 34:130-135.</p>
<div class="math">
<p><img src="../_images/math/0a85d4175df4be13afcd23aa9f144875e8bd709b.png" alt="R_{meas} = \dfrac{\sum_{hkl}{ {\left \{ 1 / [N(hkl) - 1] \right \} }^{1/2} \times \sum_{i}{|I_{i}(hkl) - \left \langle I_{i}(hkl) \right \rangle|}}}{\sum_{hkl}{\sum_{i}{I_{i}(hkl)}}}"/></p>
</div></dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.r_square">
<tt class="descname">r_square</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents.r_square" title="Permalink to this definition">¶</a></dt>
<dd><p>R-square = sum((data - mean(data))**2) / sum(data**2)</p>
</dd></dl>

<dl class="method">
<dt id="cctbx.miller.merge_equivalents.redundancies">
<tt class="descname">redundancies</tt><big>(</big><big>)</big><a class="headerlink" href="#cctbx.miller.merge_equivalents.redundancies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array representing the redundancy or multiplicity of each
reflection in the merged array.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cctbx.miller.fft_map">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">fft_map</tt><big>(</big><em>crystal_gridding</em>, <em>fourier_coefficients</em>, <em>f_000=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.fft_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for an FFT from reciprocal space (complex double) into real space.
Normally this is obtained by calling array.fft_map(...), not instantiated
directly outside this module.  If the input array is anomalous, the
resulting map will be a flex.complex_double (with grid accessor), otherwise
it will be a flex.double.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anomalous_flag</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">apply_fourier_scaling</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">apply_scaling</span></tt>(scale)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">apply_sigma_scaling</span></tt>()</td>
<td>Sigma-scale the map values in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">apply_volume_scaling</span></tt>()</td>
<td>Volume-scale the map values in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_ccp4_map</span></tt>(file_name[,&nbsp;gridding_first,&nbsp;...])</td>
<td>Write the real component of the map to a CCP4-format file.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_dsn6_map</span></tt>(file_name[,&nbsp;gridding_first,&nbsp;...])</td>
<td>Write the real component of the map to a DSN6-format file.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_xplor_map</span></tt>(file_name[,&nbsp;title_lines,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_space_group</span></tt>(space_group_info)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">complex_map</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crystal_symmetry</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_min</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mandatory_factors</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max_prime</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_grid_points</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_real</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">peak_search</span></tt>([parameters,&nbsp;verify_symmetry])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">real_map</span></tt>([direct_access])</td>
<td>Extract the real component of the FFT&#8217;d map.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">real_map_unpadded</span></tt>([in_place])</td>
<td>Extract the real component of the FFT&#8217;d map, removing any padding required for the FFT grid.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">resolution_factor</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">space_group</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">space_group_info</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">statistics</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">symmetry_flags</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">tags</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unit_cell</span></tt>()</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cctbx.miller.array_info">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">array_info</tt><big>(</big><em>source=None</em>, <em>source_type=None</em>, <em>history=None</em>, <em>labels=None</em>, <em>merged=False</em>, <em>systematic_absences_eliminated=False</em>, <em>crystal_symmetry_from_file=None</em>, <em>type_hints_from_file=None</em>, <em>wavelength=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.array_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for metadata associated with a Miller array, including labels
read from a data file.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_string_part_2</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">customized_copy</span></tt>([source,&nbsp;source_type,&nbsp;...])</td>
<td>Create a modified copy of the array_info object, keeping all attributes that are not explicitly modified.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">label_string</span></tt>()</td>
<td>A combined representation of the data labels extracted from the input file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cctbx.miller.normalised_amplitudes">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">normalised_amplitudes</tt><big>(</big><em>miller_array</em>, <em>asu_contents</em>, <em>wilson_plot=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.normalised_amplitudes" title="Permalink to this definition">¶</a></dt>
<dd><p>E-values and related statistics</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">array</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean_e_sq_minus_1</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">percent_e_sq_gt_2</span></tt>()</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cctbx.miller.crystal_symmetry_is_compatible_with_symmetry_from_file">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">crystal_symmetry_is_compatible_with_symmetry_from_file</tt><big>(</big><em>miller_array</em>, <em>unit_cell_relative_length_tolerance=0.02</em>, <em>unit_cell_absolute_angle_tolerance=3.0</em>, <em>working_point_group=None</em><big>)</big><a class="headerlink" href="#cctbx.miller.crystal_symmetry_is_compatible_with_symmetry_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">format_error_message</span></tt>(data_description)</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cctbx.miller.binner">
<em class="property">class </em><tt class="descclassname">cctbx.miller.</tt><tt class="descname">binner</tt><big>(</big><em>binning</em>, <em>miller_set</em><big>)</big><a class="headerlink" href="#cctbx.miller.binner" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">array_indices</span></tt>((&nbsp;(binner)arg1,&nbsp;...)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_simple_table</span></tt>(data,&nbsp;data_label[,&nbsp;...])</td>
<td>Export table rows for display elsewhere.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">bin_centers</span></tt>((&nbsp;(binner)arg1,&nbsp;...)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">bin_d_min</span></tt>((&nbsp;(binning)arg1,&nbsp;(int)arg2)&nbsp;-&gt;&nbsp;float&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">bin_d_range</span></tt>((&nbsp;(binning)arg1,&nbsp;...)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">bin_indices</span></tt>((&nbsp;(binner)arg1)&nbsp;-&gt;&nbsp;size_t&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">bin_legend</span></tt>(i_bin[,&nbsp;show_bin_number,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">count</span></tt>((&nbsp;(binner)arg1,&nbsp;(int)arg2)&nbsp;-&gt;&nbsp;int&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">counts</span></tt>((&nbsp;(binner)arg1)&nbsp;-&gt;&nbsp;size_t&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">counts_complete</span></tt>([include_centric,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">counts_given</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_max</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;float&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">d_min</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;float&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_i_bin</span></tt>((&nbsp;(binning)arg1,&nbsp;(float)arg2)&nbsp;-&gt;&nbsp;int&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">i_bin_d_too_large</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;int&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">i_bin_d_too_small</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;int&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate</span></tt>((&nbsp;(binner)arg1,&nbsp;(object)arg2,&nbsp;...)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">limits</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;double&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">miller_indices</span></tt>((&nbsp;(binner)arg1)&nbsp;-&gt;&nbsp;miller_index&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_bin_d_too_large</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_bin_d_too_large_or_small</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_bin_d_too_small</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_bins_all</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;int&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">n_bins_used</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;int&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">range_all</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;object&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">range_used</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;object&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">selection</span></tt>((&nbsp;(binner)arg1,&nbsp;(int)arg2)&nbsp;-&gt;&nbsp;bool&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">show_data</span></tt>(data[,&nbsp;data_fmt,&nbsp;show_bin_number,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">show_summary</span></tt>([show_bin_number,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unit_cell</span></tt>((&nbsp;(binning)arg1)&nbsp;-&gt;&nbsp;unit_cell&nbsp;:)</td>
<td>C++ signature :</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="submodules">
<h3>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cctbx.miller.display.html">cctbx.miller.display module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cctbx.miller.reindexing.html">cctbx.miller.reindexing module</a><ul class="simple">
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">cctbx.miller package</a><ul>
<li><a class="reference internal" href="#getting-started">Getting started</a></li>
<li><a class="reference internal" href="#file-i-o">File I/O</a><ul>
<li><a class="reference internal" href="#processing-input-data-practical-aspects">Processing input data - practical aspects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparing-arrays">Comparing arrays</a></li>
<li><a class="reference internal" href="#working-with-experimental-data">Working with experimental data</a></li>
<li><a class="reference internal" href="#from-arrays-to-maps">From arrays to maps</a></li>
<li><a class="reference internal" href="#the-miller-set">The Miller set</a></li>
<li><a class="reference internal" href="#the-miller-array">The Miller array</a></li>
<li><a class="reference internal" href="#utility-classes">Utility classes</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/cctbx/cctbx.miller.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">CCTBX None documentation</a> &raquo;</li>
          <li><a href="cctbx.html" >cctbx - core crystallographic objects and functions</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, University of California.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>