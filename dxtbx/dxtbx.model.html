<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dxtbx.model &mdash; CCTBX None documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'None',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="CCTBX None documentation" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CCTBX None documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dxtbx-model">
<h1><a class="toc-backref" href="#id1">dxtbx.model</a><a class="headerlink" href="#dxtbx-model" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#dxtbx-model" id="id1">dxtbx.model</a><ul>
<li><a class="reference internal" href="#module-dxtbx.model.detector" id="id2">dxtbx.model.detector</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.beam" id="id3">dxtbx.model.beam</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.scan" id="id4">dxtbx.model.scan</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.goniometer" id="id5">dxtbx.model.goniometer</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.crystal" id="id6">dxtbx.model.crystal</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="module-dxtbx.model.detector">
<span id="dxtbx-model-detector"></span><h2><a class="toc-backref" href="#id2">dxtbx.model.detector</a><a class="headerlink" href="#module-dxtbx.model.detector" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dxtbx.model.detector.detector_factory">
<em class="property">class </em><code class="descclassname">dxtbx.model.detector.</code><code class="descname">detector_factory</code><a class="headerlink" href="#dxtbx.model.detector.detector_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory class for detector objects, which will encapsulate standard
detector designs to make it a little easier to get started with these. In
cases where a CBF image is provided a full description can be used, in
other cases assumptions will be made about the experiment configuration.
In all cases information is provided in the CBF coordinate frame.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.detector.detector_factory.complex" title="dxtbx.model.detector.detector_factory.complex"><code class="xref py py-obj docutils literal"><span class="pre">complex</span></code></a>(sensor,&nbsp;origin,&nbsp;fast,&nbsp;slow,&nbsp;pixel,&nbsp;size)</td>
<td>A complex detector model, where you know exactly where everything is.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.detector.detector_factory.imgCIF" title="dxtbx.model.detector.detector_factory.imgCIF"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF</span></code></a>(cif_file,&nbsp;sensor)</td>
<td>Initialize a detector model from an imgCIF file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.detector.detector_factory.imgCIF_H" title="dxtbx.model.detector.detector_factory.imgCIF_H"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF_H</span></code></a>(cbf_handle,&nbsp;sensor)</td>
<td>Initialize a detector model from an imgCIF file handle, where it is assumed that the file has already been read.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.detector.detector_factory.make_detector" title="dxtbx.model.detector.detector_factory.make_detector"><code class="xref py py-obj docutils literal"><span class="pre">make_detector</span></code></a>(stype,&nbsp;fast_axis,&nbsp;slow_axis,&nbsp;...)</td>
<td>Ensure all types are correct before creating c++ detector class.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.detector.detector_factory.sensor" title="dxtbx.model.detector.detector_factory.sensor"><code class="xref py py-obj docutils literal"><span class="pre">sensor</span></code></a>(name)</td>
<td>Return the correct sensor token for a given name, for example:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.detector.detector_factory.simple" title="dxtbx.model.detector.detector_factory.simple"><code class="xref py py-obj docutils literal"><span class="pre">simple</span></code></a>(sensor,&nbsp;distance,&nbsp;beam_centre,&nbsp;...[,&nbsp;...])</td>
<td>Construct a simple detector at a given distance from the sample along the direct beam presumed to be aligned with -z, offset by the beam centre - the directions of which are given by the fast and slow directions, which are themselves given as +x, +y, -x, -y.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.detector.detector_factory.two_theta" title="dxtbx.model.detector.detector_factory.two_theta"><code class="xref py py-obj docutils literal"><span class="pre">two_theta</span></code></a>(sensor,&nbsp;distance,&nbsp;beam_centre,&nbsp;...)</td>
<td>Construct a simple detector at a given distance from the sample along the direct beam presumed to be aligned with -z, offset by the beam centre - the directions of which are given by the fast and slow directions, which are themselves given as +x, +y, -x, -y.</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="dxtbx.model.detector.detector_factory.complex">
<em class="property">static </em><code class="descname">complex</code><span class="sig-paren">(</span><em>sensor</em>, <em>origin</em>, <em>fast</em>, <em>slow</em>, <em>pixel</em>, <em>size</em>, <em>trusted_range=(0.0</em>, <em>0.0)</em>, <em>px_mm=None</em>, <em>gain=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.detector.detector_factory.complex" title="Permalink to this definition">¶</a></dt>
<dd><p>A complex detector model, where you know exactly where everything
is. This is useful for implementation of the Rigaku Saturn header
format, as that is exactly what is in there. Origin, fast and slow are
vectors in the CBF reference frame, pixel is the dimensions as a tuple
as is size.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.detector.detector_factory.imgCIF">
<em class="property">static </em><code class="descname">imgCIF</code><span class="sig-paren">(</span><em>cif_file</em>, <em>sensor</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.detector.detector_factory.imgCIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a detector model from an imgCIF file.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.detector.detector_factory.imgCIF_H">
<em class="property">static </em><code class="descname">imgCIF_H</code><span class="sig-paren">(</span><em>cbf_handle</em>, <em>sensor</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.detector.detector_factory.imgCIF_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a detector model from an imgCIF file handle, where it
is assumed that the file has already been read.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.detector.detector_factory.make_detector">
<em class="property">static </em><code class="descname">make_detector</code><span class="sig-paren">(</span><em>stype</em>, <em>fast_axis</em>, <em>slow_axis</em>, <em>origin</em>, <em>pixel_size</em>, <em>image_size</em>, <em>trusted_range=(0.0</em>, <em>0.0)</em>, <em>px_mm=None</em>, <em>name='Panel'</em>, <em>thickness=0.0</em>, <em>material=''</em>, <em>mu=0.0</em>, <em>gain=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.detector.detector_factory.make_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure all types are correct before creating c++ detector class.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.detector.detector_factory.sensor">
<em class="property">static </em><code class="descname">sensor</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.detector.detector_factory.sensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the correct sensor token for a given name, for example:</p>
<p>ccd, CCD
image_plate, IMAGE_PLATE
pad, PAD</p>
<p>to the appropriate static token which will be used as a handle
everywhere else in this. Also allow existing token to be passed in.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.detector.detector_factory.simple">
<em class="property">static </em><code class="descname">simple</code><span class="sig-paren">(</span><em>sensor</em>, <em>distance</em>, <em>beam_centre</em>, <em>fast_direction</em>, <em>slow_direction</em>, <em>pixel_size</em>, <em>image_size</em>, <em>trusted_range=(0.0</em>, <em>0.0)</em>, <em>mask=[]</em>, <em>px_mm=None</em>, <em>mu=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.detector.detector_factory.simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a simple detector at a given distance from the sample
along the direct beam presumed to be aligned with -z, offset by the
beam centre - the directions of which are given by the fast and slow
directions, which are themselves given as +x, +y, -x, -y. The pixel
size is given in mm in the fast and slow directions and the image size
is given in pixels in the same order. Everything else is the same as
for the main reference frame.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.detector.detector_factory.two_theta">
<em class="property">static </em><code class="descname">two_theta</code><span class="sig-paren">(</span><em>sensor</em>, <em>distance</em>, <em>beam_centre</em>, <em>fast_direction</em>, <em>slow_direction</em>, <em>two_theta_direction</em>, <em>two_theta_angle</em>, <em>pixel_size</em>, <em>image_size</em>, <em>trusted_range=(0.0</em>, <em>0.0)</em>, <em>mask=[]</em>, <em>px_mm=None</em>, <em>mu=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.detector.detector_factory.two_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a simple detector at a given distance from the sample
along the direct beam presumed to be aligned with -z, offset by the
beam centre - the directions of which are given by the fast and slow
directions, which are themselves given as +x, +y, -x, -y. The pixel
size is given in mm in the fast and slow directions and the image size
is given in pixels in the same order. Everything else is the same as
for the main reference frame. Also given are the direction of the
two-theta axis and the angle in degrees by which the detector is
moved.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dxtbx.model.beam">
<span id="dxtbx-model-beam"></span><h2><a class="toc-backref" href="#id3">dxtbx.model.beam</a><a class="headerlink" href="#module-dxtbx.model.beam" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dxtbx.model.beam.beam_factory">
<em class="property">class </em><code class="descclassname">dxtbx.model.beam.</code><code class="descname">beam_factory</code><a class="headerlink" href="#dxtbx.model.beam.beam_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory class for beam objects, which encapsulate standard beam
models. In cases where a full cbf description is available this
will be used, otherwise simplified descriptions can be applied.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.beam.beam_factory.complex" title="dxtbx.model.beam.beam_factory.complex"><code class="xref py py-obj docutils literal"><span class="pre">complex</span></code></a>(sample_to_source,&nbsp;...)</td>
<td>Full access to the constructor for cases where we do know everything that we need...</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.beam.beam_factory.imgCIF" title="dxtbx.model.beam.beam_factory.imgCIF"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF</span></code></a>(cif_file)</td>
<td>Initialize a detector model from an imgCIF file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.beam.beam_factory.imgCIF_H" title="dxtbx.model.beam.beam_factory.imgCIF_H"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF_H</span></code></a>(cbf_handle)</td>
<td>Initialize a detector model from an imgCIF file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.beam.beam_factory.make_beam" title="dxtbx.model.beam.beam_factory.make_beam"><code class="xref py py-obj docutils literal"><span class="pre">make_beam</span></code></a>([sample_to_source,&nbsp;wavelength,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.beam.beam_factory.make_polarized_beam" title="dxtbx.model.beam.beam_factory.make_polarized_beam"><code class="xref py py-obj docutils literal"><span class="pre">make_polarized_beam</span></code></a>([sample_to_source,&nbsp;...])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.beam.beam_factory.simple" title="dxtbx.model.beam.beam_factory.simple"><code class="xref py py-obj docutils literal"><span class="pre">simple</span></code></a>(wavelength)</td>
<td>Construct a beam object on the principle that the beam is aligned with the +z axis, as is quite normal.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.beam.beam_factory.simple_directional" title="dxtbx.model.beam.beam_factory.simple_directional"><code class="xref py py-obj docutils literal"><span class="pre">simple_directional</span></code></a>(sample_to_source,&nbsp;wavelength)</td>
<td>Construct a beam with direction and wavelength.</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="dxtbx.model.beam.beam_factory.complex">
<em class="property">static </em><code class="descname">complex</code><span class="sig-paren">(</span><em>sample_to_source</em>, <em>polarization_fraction</em>, <em>polarization_plane_normal</em>, <em>wavelength</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.beam.beam_factory.complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Full access to the constructor for cases where we do know everything
that we need...</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.beam.beam_factory.imgCIF">
<em class="property">static </em><code class="descname">imgCIF</code><span class="sig-paren">(</span><em>cif_file</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.beam.beam_factory.imgCIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a detector model from an imgCIF file. N.B. the
definition of the polarization plane is not completely helpful
in this - it is the angle between the polarization plane and the
+Y laboratory frame vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.beam.beam_factory.imgCIF_H">
<em class="property">static </em><code class="descname">imgCIF_H</code><span class="sig-paren">(</span><em>cbf_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.beam.beam_factory.imgCIF_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a detector model from an imgCIF file. N.B. the
definition of the polarization plane is not completely helpful
in this - it is the angle between the polarization plane and the
+Y laboratory frame vector. This example works from a cbf_handle,
which is already configured.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.beam.beam_factory.make_beam">
<em class="property">static </em><code class="descname">make_beam</code><span class="sig-paren">(</span><em>sample_to_source=None</em>, <em>wavelength=None</em>, <em>s0=None</em>, <em>unit_s0=None</em>, <em>divergence=None</em>, <em>sigma_divergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.beam.beam_factory.make_beam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.beam.beam_factory.make_polarized_beam">
<em class="property">static </em><code class="descname">make_polarized_beam</code><span class="sig-paren">(</span><em>sample_to_source=None</em>, <em>wavelength=None</em>, <em>s0=None</em>, <em>unit_s0=None</em>, <em>polarization=None</em>, <em>polarization_fraction=None</em>, <em>divergence=None</em>, <em>sigma_divergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.beam.beam_factory.make_polarized_beam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.beam.beam_factory.simple">
<em class="property">static </em><code class="descname">simple</code><span class="sig-paren">(</span><em>wavelength</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.beam.beam_factory.simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a beam object on the principle that the beam is aligned
with the +z axis, as is quite normal. Also assume the beam has
polarization fraction 0.999 and is polarized in the x-z plane.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.beam.beam_factory.simple_directional">
<em class="property">static </em><code class="descname">simple_directional</code><span class="sig-paren">(</span><em>sample_to_source</em>, <em>wavelength</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.beam.beam_factory.simple_directional" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a beam with direction and wavelength.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dxtbx.model.scan">
<span id="dxtbx-model-scan"></span><h2><a class="toc-backref" href="#id4">dxtbx.model.scan</a><a class="headerlink" href="#module-dxtbx.model.scan" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dxtbx.model.scan.scan_factory">
<em class="property">class </em><code class="descclassname">dxtbx.model.scan.</code><code class="descname">scan_factory</code><a class="headerlink" href="#dxtbx.model.scan.scan_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory for scan instances, to help with constructing the classes
in a set of common circumstances.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.scan.scan_factory.add" title="dxtbx.model.scan.scan_factory.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a>(scans)</td>
<td>Sum a list of scans wrapping the sligtly clumsy idiomatic method: sum(scans[1:], scans[0]).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.scan.scan_factory.format" title="dxtbx.model.scan.scan_factory.format"><code class="xref py py-obj docutils literal"><span class="pre">format</span></code></a>(name)</td>
<td>Return the correct format token for a given name, for example:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.scan.scan_factory.imgCIF" title="dxtbx.model.scan.scan_factory.imgCIF"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF</span></code></a>(cif_file)</td>
<td>Initialize a scan model from an imgCIF file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.scan.scan_factory.imgCIF_H" title="dxtbx.model.scan.scan_factory.imgCIF_H"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF_H</span></code></a>(cif_file,&nbsp;cbf_handle)</td>
<td>Initialize a scan model from an imgCIF file handle, where it is assumed that the file has already been read.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.scan.scan_factory.make_scan" title="dxtbx.model.scan.scan_factory.make_scan"><code class="xref py py-obj docutils literal"><span class="pre">make_scan</span></code></a>(image_range,&nbsp;exposure_times,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.scan.scan_factory.search" title="dxtbx.model.scan.scan_factory.search"><code class="xref py py-obj docutils literal"><span class="pre">search</span></code></a>(filename)</td>
<td>Get a list of files which appear to match the template and directory implied by the input filename.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.scan.scan_factory.single" title="dxtbx.model.scan.scan_factory.single"><code class="xref py py-obj docutils literal"><span class="pre">single</span></code></a>(filename,&nbsp;format,&nbsp;exposure_times,&nbsp;...)</td>
<td>Construct an scan instance for a single image.</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="dxtbx.model.scan.scan_factory.add">
<em class="property">static </em><code class="descname">add</code><span class="sig-paren">(</span><em>scans</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.scan.scan_factory.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum a list of scans wrapping the sligtly clumsy idiomatic method:
sum(scans[1:], scans[0]).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.scan.scan_factory.format">
<em class="property">static </em><code class="descname">format</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.scan.scan_factory.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the correct format token for a given name, for example:</p>
<p>cbf, CBF
smv, SMV
tiff, tif, TIFF
raxis, RAXIS
mar, MAR</p>
<p>to the appropriate static token which will be used as a handle
everywhere else in this.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.scan.scan_factory.imgCIF">
<em class="property">static </em><code class="descname">imgCIF</code><span class="sig-paren">(</span><em>cif_file</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.scan.scan_factory.imgCIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scan model from an imgCIF file.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.scan.scan_factory.imgCIF_H">
<em class="property">static </em><code class="descname">imgCIF_H</code><span class="sig-paren">(</span><em>cif_file</em>, <em>cbf_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.scan.scan_factory.imgCIF_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a scan model from an imgCIF file handle, where it is
assumed that the file has already been read.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.scan.scan_factory.make_scan">
<em class="property">static </em><code class="descname">make_scan</code><span class="sig-paren">(</span><em>image_range</em>, <em>exposure_times</em>, <em>oscillation</em>, <em>epochs</em>, <em>deg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.scan.scan_factory.make_scan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.scan.scan_factory.search">
<em class="property">static </em><code class="descname">search</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.scan.scan_factory.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of files which appear to match the template and
directory implied by the input filename. This could well be used
to get a list of image headers to read and hence construct scans
from.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.scan.scan_factory.single">
<em class="property">static </em><code class="descname">single</code><span class="sig-paren">(</span><em>filename</em>, <em>format</em>, <em>exposure_times</em>, <em>osc_start</em>, <em>osc_width</em>, <em>epoch</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.scan.scan_factory.single" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an scan instance for a single image.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dxtbx.model.goniometer">
<span id="dxtbx-model-goniometer"></span><h2><a class="toc-backref" href="#id5">dxtbx.model.goniometer</a><a class="headerlink" href="#module-dxtbx.model.goniometer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dxtbx.model.goniometer.goniometer_factory">
<em class="property">class </em><code class="descclassname">dxtbx.model.goniometer.</code><code class="descname">goniometer_factory</code><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory class for goniometer objects, which will encapsulate
some standard goniometer designs to make it a little easier to get
started with all of this - for cases when we are not using a CBF.
When we have a CBF just use that factory method and everything will be
peachy.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.imgCIF" title="dxtbx.model.goniometer.goniometer_factory.imgCIF"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF</span></code></a>(cif_file)</td>
<td>Initialize a goniometer model from an imgCIF file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.imgCIF_H" title="dxtbx.model.goniometer.goniometer_factory.imgCIF_H"><code class="xref py py-obj docutils literal"><span class="pre">imgCIF_H</span></code></a>(cbf_handle)</td>
<td>Initialize a goniometer model from an imgCIF file handle, where it is assumed that the file has already been read.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.kappa" title="dxtbx.model.goniometer.goniometer_factory.kappa"><code class="xref py py-obj docutils literal"><span class="pre">kappa</span></code></a>(alpha,&nbsp;omega,&nbsp;kappa,&nbsp;phi,&nbsp;direction,&nbsp;...)</td>
<td>Return a kappa goniometer where omega is the primary axis (i,e.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.known_axis" title="dxtbx.model.goniometer.goniometer_factory.known_axis"><code class="xref py py-obj docutils literal"><span class="pre">known_axis</span></code></a>(axis)</td>
<td>Return an goniometer instance for a known rotation axis, assuming that nothing is known about the fixed element of the rotation axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.make_goniometer" title="dxtbx.model.goniometer.goniometer_factory.make_goniometer"><code class="xref py py-obj docutils literal"><span class="pre">make_goniometer</span></code></a>(rotation_axis,&nbsp;fixed_rotation)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.make_kappa_goniometer" title="dxtbx.model.goniometer.goniometer_factory.make_kappa_goniometer"><code class="xref py py-obj docutils literal"><span class="pre">make_kappa_goniometer</span></code></a>(alpha,&nbsp;omega,&nbsp;kappa,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.make_multi_axis_goniometer" title="dxtbx.model.goniometer.goniometer_factory.make_multi_axis_goniometer"><code class="xref py py-obj docutils literal"><span class="pre">make_multi_axis_goniometer</span></code></a>(axes,&nbsp;angles,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.multi_axis" title="dxtbx.model.goniometer.goniometer_factory.multi_axis"><code class="xref py py-obj docutils literal"><span class="pre">multi_axis</span></code></a>(axes,&nbsp;angles,&nbsp;scan_axis)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.single_axis" title="dxtbx.model.goniometer.goniometer_factory.single_axis"><code class="xref py py-obj docutils literal"><span class="pre">single_axis</span></code></a>()</td>
<td>Construct a single axis goniometer which is canonical in the CBF reference frame.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.goniometer.goniometer_factory.single_axis_reverse" title="dxtbx.model.goniometer.goniometer_factory.single_axis_reverse"><code class="xref py py-obj docutils literal"><span class="pre">single_axis_reverse</span></code></a>()</td>
<td>Construct a single axis goniometer which is canonical in the CBF reference frame, but reversed in rotation.</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.imgCIF">
<em class="property">static </em><code class="descname">imgCIF</code><span class="sig-paren">(</span><em>cif_file</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.imgCIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a goniometer model from an imgCIF file.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.imgCIF_H">
<em class="property">static </em><code class="descname">imgCIF_H</code><span class="sig-paren">(</span><em>cbf_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.imgCIF_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a goniometer model from an imgCIF file handle, where
it is assumed that the file has already been read.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.kappa">
<em class="property">static </em><code class="descname">kappa</code><span class="sig-paren">(</span><em>alpha</em>, <em>omega</em>, <em>kappa</em>, <em>phi</em>, <em>direction</em>, <em>scan_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.kappa" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a kappa goniometer where omega is the primary axis (i,e.
aligned with X in the CBF coordinate frame) and has the kappa arm
with angle alpha attached to it, aligned with -z, +y, +z or -y at
omega = 0, that being the direction, which in turn has phi fixed to it
which should initially be coincident with omega. We also need to know
which axis is being used for the scan i.e. phi or omega. All angles
should be given in degrees. This will work by first constructing the
rotation axes and then composing them to the scan axis and fixed
component of the rotation.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.known_axis">
<em class="property">static </em><code class="descname">known_axis</code><span class="sig-paren">(</span><em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.known_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an goniometer instance for a known rotation axis, assuming
that nothing is known about the fixed element of the rotation axis.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.make_goniometer">
<em class="property">static </em><code class="descname">make_goniometer</code><span class="sig-paren">(</span><em>rotation_axis</em>, <em>fixed_rotation</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.make_goniometer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.make_kappa_goniometer">
<em class="property">static </em><code class="descname">make_kappa_goniometer</code><span class="sig-paren">(</span><em>alpha</em>, <em>omega</em>, <em>kappa</em>, <em>phi</em>, <em>direction</em>, <em>scan_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.make_kappa_goniometer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.make_multi_axis_goniometer">
<em class="property">static </em><code class="descname">make_multi_axis_goniometer</code><span class="sig-paren">(</span><em>axes</em>, <em>angles</em>, <em>scan_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.make_multi_axis_goniometer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.multi_axis">
<em class="property">static </em><code class="descname">multi_axis</code><span class="sig-paren">(</span><em>axes</em>, <em>angles</em>, <em>scan_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.multi_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.single_axis">
<em class="property">static </em><code class="descname">single_axis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.single_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a single axis goniometer which is canonical in the
CBF reference frame.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="dxtbx.model.goniometer.goniometer_factory.single_axis_reverse">
<em class="property">static </em><code class="descname">single_axis_reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.goniometer.goniometer_factory.single_axis_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a single axis goniometer which is canonical in the
CBF reference frame, but reversed in rotation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-dxtbx.model.crystal">
<span id="dxtbx-model-crystal"></span><h2><a class="toc-backref" href="#id6">dxtbx.model.crystal</a><a class="headerlink" href="#module-dxtbx.model.crystal" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dxtbx.model.crystal.crystal_model">
<em class="property">class </em><code class="descclassname">dxtbx.model.crystal.</code><code class="descname">crystal_model</code><span class="sig-paren">(</span><em>real_space_a</em>, <em>real_space_b</em>, <em>real_space_c</em>, <em>space_group_symbol=None</em>, <em>space_group=None</em>, <em>mosaicity=None</em>, <em>deg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Simple model for the crystal lattice geometry and symmetry</p>
<p>A crystal is initialised from the elements of its real space axes
a, b, and c. Space group information must also be provided, either
in the form of a symbol, or an existing
cctbx.sgtbx.space_group object. If space_group_symbol is provided,
it is passed to the cctbx.sgtbx.space_group_symbols constructor.
This accepts either extended Hermann Mauguin format, or Hall format
with the prefix &#8216;Hall:&#8217;. E.g.</p>
<dl class="docutils">
<dt>space_group_symbol = &#8220;P b a n:1&#8221;</dt>
<dd>or</dd>
</dl>
<p>space_group_symbol = &#8220;Hall:P 2 2 -1ab&#8221;</p>
<p>Optionally the crystal mosaicity value may be set, with the deg
parameter controlling whether this value is treated as being an
angle in degrees or radians.</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.num_scan_points" title="dxtbx.model.crystal.crystal_model.num_scan_points"><code class="xref py py-obj docutils literal"><span class="pre">num_scan_points</span></code></a></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.change_basis" title="dxtbx.model.crystal.crystal_model.change_basis"><code class="xref py py-obj docutils literal"><span class="pre">change_basis</span></code></a>(change_of_basis_op)</td>
<td>Returns a copy of the current crystal model transformed by the given change of basis operator to the new basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_A" title="dxtbx.model.crystal.crystal_model.get_A"><code class="xref py py-obj docutils literal"><span class="pre">get_A</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_A_at_scan_point" title="dxtbx.model.crystal.crystal_model.get_A_at_scan_point"><code class="xref py py-obj docutils literal"><span class="pre">get_A_at_scan_point</span></code></a>(t)</td>
<td>Return the setting matrix with index t.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_B" title="dxtbx.model.crystal.crystal_model.get_B"><code class="xref py py-obj docutils literal"><span class="pre">get_B</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_B_at_scan_point" title="dxtbx.model.crystal.crystal_model.get_B_at_scan_point"><code class="xref py py-obj docutils literal"><span class="pre">get_B_at_scan_point</span></code></a>(t)</td>
<td>Return orthogonalisation matrix with index t.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_B_covariance" title="dxtbx.model.crystal.crystal_model.get_B_covariance"><code class="xref py py-obj docutils literal"><span class="pre">get_B_covariance</span></code></a>()</td>
<td>Return the 9*9 covariance matrix of elements of B, if available, otherwise None.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_U" title="dxtbx.model.crystal.crystal_model.get_U"><code class="xref py py-obj docutils literal"><span class="pre">get_U</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_U_at_scan_point" title="dxtbx.model.crystal.crystal_model.get_U_at_scan_point"><code class="xref py py-obj docutils literal"><span class="pre">get_U_at_scan_point</span></code></a>(t)</td>
<td>Return orientation matrix with index t.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_cell_parameter_sd" title="dxtbx.model.crystal.crystal_model.get_cell_parameter_sd"><code class="xref py py-obj docutils literal"><span class="pre">get_cell_parameter_sd</span></code></a>()</td>
<td>Return the estimated standard deviations of unit cell parameters in units of Angstroms and degrees, if available, otherwise None.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_cell_volume_sd" title="dxtbx.model.crystal.crystal_model.get_cell_volume_sd"><code class="xref py py-obj docutils literal"><span class="pre">get_cell_volume_sd</span></code></a>()</td>
<td>Return the estimated standard deviation of the unit cell volume in units of Angstroms^3, if available, otherwise None.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_mosaicity" title="dxtbx.model.crystal.crystal_model.get_mosaicity"><code class="xref py py-obj docutils literal"><span class="pre">get_mosaicity</span></code></a>([deg])</td>
<td>Get the current value of the mosaicity.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_real_space_vectors" title="dxtbx.model.crystal.crystal_model.get_real_space_vectors"><code class="xref py py-obj docutils literal"><span class="pre">get_real_space_vectors</span></code></a>()</td>
<td>Get the real space unit cell basis vectors.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_space_group" title="dxtbx.model.crystal.crystal_model.get_space_group"><code class="xref py py-obj docutils literal"><span class="pre">get_space_group</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">returns:</th><td class="field-body">The current space group</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_unit_cell" title="dxtbx.model.crystal.crystal_model.get_unit_cell"><code class="xref py py-obj docutils literal"><span class="pre">get_unit_cell</span></code></a>()</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">returns:</th><td class="field-body">The unit cell</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.get_unit_cell_at_scan_point" title="dxtbx.model.crystal.crystal_model.get_unit_cell_at_scan_point"><code class="xref py py-obj docutils literal"><span class="pre">get_unit_cell_at_scan_point</span></code></a>(t)</td>
<td>Return unit cell with index t.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.is_similar_to" title="dxtbx.model.crystal.crystal_model.is_similar_to"><code class="xref py py-obj docutils literal"><span class="pre">is_similar_to</span></code></a>(other[,&nbsp;angle_tolerance,&nbsp;...])</td>
<td>Test similarity of this to another crystal model</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.reset_scan_points" title="dxtbx.model.crystal.crystal_model.reset_scan_points"><code class="xref py py-obj docutils literal"><span class="pre">reset_scan_points</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.reset_unit_cell_errors" title="dxtbx.model.crystal.crystal_model.reset_unit_cell_errors"><code class="xref py py-obj docutils literal"><span class="pre">reset_unit_cell_errors</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.rotate_around_origin" title="dxtbx.model.crystal.crystal_model.rotate_around_origin"><code class="xref py py-obj docutils literal"><span class="pre">rotate_around_origin</span></code></a>(axis,&nbsp;angle[,&nbsp;deg])</td>
<td>Rotate the model around an axis and angle</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_A" title="dxtbx.model.crystal.crystal_model.set_A"><code class="xref py py-obj docutils literal"><span class="pre">set_A</span></code></a>(A)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_A_at_scan_points" title="dxtbx.model.crystal.crystal_model.set_A_at_scan_points"><code class="xref py py-obj docutils literal"><span class="pre">set_A_at_scan_points</span></code></a>(A_list)</td>
<td>Set the setting matrix A at a series of checkpoints within a rotation scan.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_B" title="dxtbx.model.crystal.crystal_model.set_B"><code class="xref py py-obj docutils literal"><span class="pre">set_B</span></code></a>(B)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_B_covariance" title="dxtbx.model.crystal.crystal_model.set_B_covariance"><code class="xref py py-obj docutils literal"><span class="pre">set_B_covariance</span></code></a>(cov)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_U" title="dxtbx.model.crystal.crystal_model.set_U"><code class="xref py py-obj docutils literal"><span class="pre">set_U</span></code></a>(U)</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_mosaicity" title="dxtbx.model.crystal.crystal_model.set_mosaicity"><code class="xref py py-obj docutils literal"><span class="pre">set_mosaicity</span></code></a>(mosaicity[,&nbsp;deg])</td>
<td>Update the value of the mosaicity.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_space_group" title="dxtbx.model.crystal.crystal_model.set_space_group"><code class="xref py py-obj docutils literal"><span class="pre">set_space_group</span></code></a>(space_group)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param space_group:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.set_unit_cell" title="dxtbx.model.crystal.crystal_model.set_unit_cell"><code class="xref py py-obj docutils literal"><span class="pre">set_unit_cell</span></code></a>(real_space_a,&nbsp;real_space_b,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.show" title="dxtbx.model.crystal.crystal_model.show"><code class="xref py py-obj docutils literal"><span class="pre">show</span></code></a>([show_scan_varying,&nbsp;out])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dxtbx.model.crystal.crystal_model.update" title="dxtbx.model.crystal.crystal_model.update"><code class="xref py py-obj docutils literal"><span class="pre">update</span></code></a>(other)</td>
<td>Update the current crystal model such that self == other.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.change_basis">
<code class="descname">change_basis</code><span class="sig-paren">(</span><em>change_of_basis_op</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.change_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the current crystal model transformed by the given
change of basis operator to the new basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>change_of_basis_op</strong> &#8211; The change of basis operator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The crystal model transformed to the new basis.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#dxtbx.model.crystal.crystal_model" title="dxtbx.model.crystal.crystal_model"><code class="xref py py-class docutils literal"><span class="pre">crystal_model</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_A">
<code class="descname">get_A</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_A_at_scan_point">
<code class="descname">get_A_at_scan_point</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_A_at_scan_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the setting matrix with index t.</p>
<p>This will typically have been
set with reference to a particular scan, such that it equals the UB matrix
appropriate at the start of the rotation for the image with array index t</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> &#8211; index into the list of scan points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The A matrix at index t</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../scitbx/scitbx.matrix.html#scitbx.matrix.sqr" title="scitbx.matrix.sqr"><code class="xref py py-class docutils literal"><span class="pre">scitbx.matrix.sqr</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_B">
<code class="descname">get_B</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_B" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_B_at_scan_point">
<code class="descname">get_B_at_scan_point</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_B_at_scan_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return orthogonalisation matrix with index t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> &#8211; index into the list of scan points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The B matrix at index t</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../scitbx/scitbx.matrix.html#scitbx.matrix.sqr" title="scitbx.matrix.sqr"><code class="xref py py-class docutils literal"><span class="pre">scitbx.matrix.sqr</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_B_covariance">
<code class="descname">get_B_covariance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_B_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 9*9 covariance matrix of elements of B, if available,
otherwise None. The order of elements of this matrix are determined by
&#8216;flattening&#8217; B to form a 1D vector using row major ordering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../scitbx/scitbx.matrix.html#scitbx.matrix.sqr" title="scitbx.matrix.sqr"><code class="xref py py-class docutils literal"><span class="pre">scitbx.matrix.sqr</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_U">
<code class="descname">get_U</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_U" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_U_at_scan_point">
<code class="descname">get_U_at_scan_point</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_U_at_scan_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return orientation matrix with index t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> &#8211; index into the list of scan points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The U matrix at index t</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../scitbx/scitbx.matrix.html#scitbx.matrix.sqr" title="scitbx.matrix.sqr"><code class="xref py py-class docutils literal"><span class="pre">scitbx.matrix.sqr</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_cell_parameter_sd">
<code class="descname">get_cell_parameter_sd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_cell_parameter_sd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the estimated standard deviations of unit cell parameters in
units of Angstroms and degrees, if available, otherwise None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_cell_volume_sd">
<code class="descname">get_cell_volume_sd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_cell_volume_sd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the estimated standard deviation of the unit cell volume in
units of Angstroms^3, if available, otherwise None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_mosaicity">
<code class="descname">get_mosaicity</code><span class="sig-paren">(</span><em>deg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_mosaicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current value of the mosaicity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deg</strong> (<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.bool" title="scitbx.array_family.flex.bool"><em>bool</em></a>) &#8211; If True, return the mosaicity in degrees, else return the
mosaicity in radians.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The mosaicity</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_real_space_vectors">
<code class="descname">get_real_space_vectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_real_space_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the real space unit cell basis vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Real space unit cell basis vectors</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list of <a class="reference internal" href="../scitbx/scitbx.matrix.html#scitbx.matrix.col" title="scitbx.matrix.col"><code class="xref py py-class docutils literal"><span class="pre">scitbx.matrix.col</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_space_group">
<code class="descname">get_space_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_space_group" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The current space group</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-class docutils literal"><span class="pre">cctbx.sgtbx.space_group</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_unit_cell">
<code class="descname">get_unit_cell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_unit_cell" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The unit cell</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../cctbx/cctbx.uctbx.html#cctbx.uctbx.unit_cell" title="cctbx.uctbx.unit_cell"><code class="xref py py-class docutils literal"><span class="pre">cctbx.uctbx.unit_cell</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.get_unit_cell_at_scan_point">
<code class="descname">get_unit_cell_at_scan_point</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.get_unit_cell_at_scan_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unit cell with index t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> (<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.int" title="scitbx.array_family.flex.int"><em>int</em></a>) &#8211; index into the list of scan points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The unit cell at index t</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../cctbx/cctbx.uctbx.html#cctbx.uctbx.unit_cell" title="cctbx.uctbx.unit_cell"><code class="xref py py-class docutils literal"><span class="pre">cctbx.uctbx.unit_cell</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.is_similar_to">
<code class="descname">is_similar_to</code><span class="sig-paren">(</span><em>other</em>, <em>angle_tolerance=0.01</em>, <em>mosaicity_tolerance=0.8</em>, <em>uc_rel_length_tolerance=0.01</em>, <em>uc_abs_angle_tolerance=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.is_similar_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Test similarity of this to another crystal model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other</strong> (<a class="reference internal" href="#dxtbx.model.crystal.crystal_model" title="dxtbx.model.crystal.crystal_model"><em>crystal_model</em></a>) &#8211; the crystal model to test against</li>
<li><strong>angle_tolerance</strong> (<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.float" title="scitbx.array_family.flex.float"><em>float</em></a>) &#8211; maximum tolerated orientation difference in degrees</li>
<li><strong>mosaicity_tolerance</strong> &#8211; minimum tolerated fraction of the larger
mosaicity for the smaller mosaicity to retain similarity</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:type mosaicity_tolerance:float
:param uc_rel_length_tolerance: relative length tolerance to pass to</p>
<blockquote>
<div>unit_cell.is_similar_to</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>uc_abs_angle_tolerance</strong> (<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.float" title="scitbx.array_family.flex.float"><em>float</em></a>) &#8211; absolute angle tolerance to pass to
unit_cell.is_similar_to</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Whether the other crystal model is similar to this</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.bool" title="scitbx.array_family.flex.bool">bool</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dxtbx.model.crystal.crystal_model.num_scan_points">
<code class="descname">num_scan_points</code><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.num_scan_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.reset_scan_points">
<code class="descname">reset_scan_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.reset_scan_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.reset_unit_cell_errors">
<code class="descname">reset_unit_cell_errors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.reset_unit_cell_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.rotate_around_origin">
<code class="descname">rotate_around_origin</code><span class="sig-paren">(</span><em>axis</em>, <em>angle</em>, <em>deg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.rotate_around_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the model around an axis and angle</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> &#8211; The axis to rotate around</li>
<li><strong>angle</strong> &#8211; The angle to rotate around</li>
<li><strong>deg</strong> &#8211; Degrees or radians</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_A">
<code class="descname">set_A</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_A_at_scan_points">
<code class="descname">set_A_at_scan_points</code><span class="sig-paren">(</span><em>A_list</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_A_at_scan_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the setting matrix A at a series of checkpoints within a rotation
scan. There would typically be n+1 points, where n is the number of images
in the scan. The first point is the state at the beginning of the rotation
scan. The final point is the state at the end of the rotation scan.
Intervening points give the state at the start of the rotation at the 2nd
to the nth image.</p>
<p>This data is held separately from the &#8216;static&#8217; U and B because per-image
setting matrices may be refined whilst restraining to a previously
determined best-fit static UB. The values will be reset if any changes are
made to the static U and B matrices.</p>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_B">
<code class="descname">set_B</code><span class="sig-paren">(</span><em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_B" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_B_covariance">
<code class="descname">set_B_covariance</code><span class="sig-paren">(</span><em>cov</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_B_covariance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_U">
<code class="descname">set_U</code><span class="sig-paren">(</span><em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_U" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_mosaicity">
<code class="descname">set_mosaicity</code><span class="sig-paren">(</span><em>mosaicity</em>, <em>deg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_mosaicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the value of the mosaicity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mosaicity</strong> (<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.float" title="scitbx.array_family.flex.float"><em>float</em></a>) &#8211; The mosaicity</li>
<li><strong>deg</strong> (<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.bool" title="scitbx.array_family.flex.bool"><em>bool</em></a>) &#8211; If True, assume the mosaicity is given in degrees, else
assume it is given in radians.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The mosaicity</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_space_group">
<code class="descname">set_space_group</code><span class="sig-paren">(</span><em>space_group</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_space_group" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>space_group</strong> (<em>cctbx.sgtbx.space_group</em>) &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.set_unit_cell">
<code class="descname">set_unit_cell</code><span class="sig-paren">(</span><em>real_space_a</em>, <em>real_space_b</em>, <em>real_space_c</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.set_unit_cell" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>show_scan_varying=False</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.show" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dxtbx.model.crystal.crystal_model.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the current crystal model such that self == other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#dxtbx.model.crystal.crystal_model" title="dxtbx.model.crystal.crystal_model"><em>crystal_model</em></a>) &#8211; A crystal model to update self with.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dxtbx.model.crystal.crystal_model_from_mosflm_matrix">
<code class="descclassname">dxtbx.model.crystal.</code><code class="descname">crystal_model_from_mosflm_matrix</code><span class="sig-paren">(</span><em>mosflm_A_matrix</em>, <em>unit_cell=None</em>, <em>wavelength=None</em>, <em>space_group=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dxtbx.model.crystal.crystal_model_from_mosflm_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a crystal_model from a Mosflm A matrix (a*, b*, c*); N.B. assumes
the mosflm coordinate frame:</p>
<div class="highlight-default"><div class="highlight"><pre>                                   /!
      Y-axis                      / !
        ^                        /  !
        !                       /   !
        !                      /    !
        !   /                 /  Xd !
        !  /                 / * ^  !
        ! /                  ! 3 !  !
        !/      X-ray beam   !   !  !
        /------------------------/--!----&gt;X-axis
       /                     !  / *1!
    &lt;-/-                     ! /    !
     /  \+ve phi             ! Yd  /
    /   /                    ! 2  /
   /                         ! * /
  Z-axis                  Ys ^ _/
Rotation                     ! /| Xs
 axis                        !/
                             O
</pre></div>
</div>
<p>Also assume that the mosaic spread is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mosflm_A_matrix</strong> (<em>tuple of floats</em>) &#8211; The A matrix in Mosflm convention.</li>
<li><strong>unit_cell</strong> (<a class="reference internal" href="../cctbx/cctbx.uctbx.html#cctbx.uctbx.unit_cell" title="cctbx.uctbx.unit_cell"><em>cctbx.uctbx.unit_cell</em></a>) &#8211; The unit cell parameters which are used to determine the
wavelength from the Mosflm A matrix.</li>
<li><strong>wavelength</strong> (<a class="reference internal" href="../scitbx/scitbx.array_family.html#scitbx.array_family.flex.float" title="scitbx.array_family.flex.float"><em>float</em></a>) &#8211; The wavelength to scale the A matrix</li>
<li><strong>space_group</strong> (<em>cctbx.sgtbx.space_group</em>) &#8211; If the space group is None then the space_group will
be assigned as P1</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A crystal model derived from the given Mosflm A matrix</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#dxtbx.model.crystal.crystal_model" title="dxtbx.model.crystal.crystal_model"><code class="xref py py-class docutils literal"><span class="pre">crystal_model</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">dxtbx.model</a><ul>
<li><a class="reference internal" href="#module-dxtbx.model.detector">dxtbx.model.detector</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.beam">dxtbx.model.beam</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.scan">dxtbx.model.scan</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.goniometer">dxtbx.model.goniometer</a></li>
<li><a class="reference internal" href="#module-dxtbx.model.crystal">dxtbx.model.crystal</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/dxtbx/dxtbx.model.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CCTBX None documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, University of California.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
  </body>
</html>